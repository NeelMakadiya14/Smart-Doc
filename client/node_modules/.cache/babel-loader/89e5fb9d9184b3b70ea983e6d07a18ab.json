{"ast":null,"code":"import _classCallCheck from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\nUnlike stated in the LICENSE file, it is not necessary to include the copyright notice and permission notice when you copy code from this file.\n*/\n\n/**\n * @module provider/websocket\n */\n\n/* eslint-env browser */\nimport * as Y from 'yjs'; // eslint-disable-line\n\nimport * as bc from 'lib0/broadcastchannel.js';\nimport * as time from 'lib0/time.js';\nimport * as encoding from 'lib0/encoding.js';\nimport * as decoding from 'lib0/decoding.js';\nimport * as syncProtocol from 'y-protocols/sync.js';\nimport * as authProtocol from 'y-protocols/auth.js';\nimport * as awarenessProtocol from 'y-protocols/awareness.js';\nimport * as mutex from 'lib0/mutex.js';\nimport { Observable } from 'lib0/observable.js';\nimport * as math from 'lib0/math.js';\nimport * as url from 'lib0/url.js';\nvar messageSync = 0;\nvar messageQueryAwareness = 3;\nvar messageAwareness = 1;\nvar messageAuth = 2;\n/**\n *                       encoder,          decoder,          provider,          emitSynced, messageType\n * @type {Array<function(encoding.Encoder, decoding.Decoder, WebsocketProvider, boolean,    number):void>}\n */\n\nvar messageHandlers = [];\n\nmessageHandlers[messageSync] = function (encoder, decoder, provider, emitSynced, messageType) {\n  encoding.writeVarUint(encoder, messageSync);\n  var syncMessageType = syncProtocol.readSyncMessage(decoder, encoder, provider.doc, provider);\n\n  if (emitSynced && syncMessageType === syncProtocol.messageYjsSyncStep2 && !provider.synced) {\n    provider.synced = true;\n  }\n};\n\nmessageHandlers[messageQueryAwareness] = function (encoder, decoder, provider, emitSynced, messageType) {\n  encoding.writeVarUint(encoder, messageAwareness);\n  encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));\n};\n\nmessageHandlers[messageAwareness] = function (encoder, decoder, provider, emitSynced, messageType) {\n  awarenessProtocol.applyAwarenessUpdate(provider.awareness, decoding.readVarUint8Array(decoder), provider);\n};\n\nmessageHandlers[messageAuth] = function (encoder, decoder, provider, emitSynced, messageType) {\n  authProtocol.readAuthMessage(decoder, provider.doc, permissionDeniedHandler);\n};\n\nvar reconnectTimeoutBase = 1200;\nvar maxReconnectTimeout = 2500; // @todo - this should depend on awareness.outdatedTime\n\nvar messageReconnectTimeout = 30000;\n/**\n * @param {WebsocketProvider} provider\n * @param {string} reason\n */\n\nvar permissionDeniedHandler = function permissionDeniedHandler(provider, reason) {\n  return console.warn(\"Permission denied to access \".concat(provider.url, \".\\n\").concat(reason));\n};\n/**\n * @param {WebsocketProvider} provider\n * @param {Uint8Array} buf\n * @param {boolean} emitSynced\n * @return {encoding.Encoder}\n */\n\n\nvar readMessage = function readMessage(provider, buf, emitSynced) {\n  var decoder = decoding.createDecoder(buf);\n  var encoder = encoding.createEncoder();\n  var messageType = decoding.readVarUint(decoder);\n  var messageHandler = provider.messageHandlers[messageType];\n\n  if (\n  /** @type {any} */\n  messageHandler) {\n    messageHandler(encoder, decoder, provider, emitSynced, messageType);\n  } else {\n    console.error('Unable to compute message');\n  }\n\n  return encoder;\n};\n/**\n * @param {WebsocketProvider} provider\n */\n\n\nvar setupWS = function setupWS(provider) {\n  if (provider.shouldConnect && provider.ws === null) {\n    var websocket = new provider._WS(provider.url);\n    websocket.binaryType = 'arraybuffer';\n    provider.ws = websocket;\n    provider.wsconnecting = true;\n    provider.wsconnected = false;\n    provider.synced = false;\n\n    websocket.onmessage = function (event) {\n      provider.wsLastMessageReceived = time.getUnixTime();\n      var encoder = readMessage(provider, new Uint8Array(event.data), true);\n\n      if (encoding.length(encoder) > 1) {\n        websocket.send(encoding.toUint8Array(encoder));\n      }\n    };\n\n    websocket.onclose = function () {\n      provider.ws = null;\n      provider.wsconnecting = false;\n\n      if (provider.wsconnected) {\n        provider.wsconnected = false;\n        provider.synced = false; // update awareness (all users except local left)\n\n        awarenessProtocol.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter(function (client) {\n          return client !== provider.doc.clientID;\n        }), provider);\n        provider.emit('status', [{\n          status: 'disconnected'\n        }]);\n      } else {\n        provider.wsUnsuccessfulReconnects++;\n      } // Start with no reconnect timeout and increase timeout by\n      // log10(wsUnsuccessfulReconnects).\n      // The idea is to increase reconnect timeout slowly and have no reconnect\n      // timeout at the beginning (log(1) = 0)\n\n\n      setTimeout(setupWS, math.min(math.log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider);\n    };\n\n    websocket.onopen = function () {\n      provider.wsLastMessageReceived = time.getUnixTime();\n      provider.wsconnecting = false;\n      provider.wsconnected = true;\n      provider.wsUnsuccessfulReconnects = 0;\n      provider.emit('status', [{\n        status: 'connected'\n      }]); // always send sync step 1 when connected\n\n      var encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageSync);\n      syncProtocol.writeSyncStep1(encoder, provider.doc);\n      websocket.send(encoding.toUint8Array(encoder)); // broadcast local awareness state\n\n      if (provider.awareness.getLocalState() !== null) {\n        var encoderAwarenessState = encoding.createEncoder();\n        encoding.writeVarUint(encoderAwarenessState, messageAwareness);\n        encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID]));\n        websocket.send(encoding.toUint8Array(encoderAwarenessState));\n      }\n    };\n\n    provider.emit('status', [{\n      status: 'connecting'\n    }]);\n  }\n};\n/**\n * @param {WebsocketProvider} provider\n * @param {ArrayBuffer} buf\n */\n\n\nvar broadcastMessage = function broadcastMessage(provider, buf) {\n  if (provider.wsconnected) {\n    // @ts-ignore We know that wsconnected = true\n    provider.ws.send(buf);\n  }\n\n  if (provider.bcconnected) {\n    provider.mux(function () {\n      bc.publish(provider.bcChannel, buf);\n    });\n  }\n};\n/**\n * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.\n * The document name is attached to the provided url. I.e. the following example\n * creates a websocket connection to http://localhost:1234/my-document-name\n *\n * @example\n *   import * as Y from 'yjs'\n *   import { WebsocketProvider } from 'y-websocket'\n *   const doc = new Y.Doc()\n *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)\n *\n * @extends {Observable<string>}\n */\n\n\nexport var WebsocketProvider = /*#__PURE__*/function (_Observable) {\n  _inherits(WebsocketProvider, _Observable);\n\n  var _super = _createSuper(WebsocketProvider);\n\n  /**\n   * @param {string} serverUrl\n   * @param {string} roomname\n   * @param {Y.Doc} doc\n   * @param {object} [opts]\n   * @param {boolean} [opts.connect]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {Object<string,string>} [opts.params]\n   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill\n   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds\n   */\n  function WebsocketProvider(serverUrl, roomname, doc) {\n    var _this;\n\n    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref$connect = _ref.connect,\n        connect = _ref$connect === void 0 ? true : _ref$connect,\n        _ref$awareness = _ref.awareness,\n        awareness = _ref$awareness === void 0 ? new awarenessProtocol.Awareness(doc) : _ref$awareness,\n        _ref$params = _ref.params,\n        params = _ref$params === void 0 ? {} : _ref$params,\n        _ref$WebSocketPolyfil = _ref.WebSocketPolyfill,\n        WebSocketPolyfill = _ref$WebSocketPolyfil === void 0 ? WebSocket : _ref$WebSocketPolyfil,\n        _ref$resyncInterval = _ref.resyncInterval,\n        resyncInterval = _ref$resyncInterval === void 0 ? -1 : _ref$resyncInterval;\n\n    _classCallCheck(this, WebsocketProvider);\n\n    _this = _super.call(this); // ensure that url is always ends with /\n\n    while (serverUrl[serverUrl.length - 1] === '/') {\n      serverUrl = serverUrl.slice(0, serverUrl.length - 1);\n    }\n\n    var encodedParams = url.encodeQueryParams(params);\n    _this.bcChannel = serverUrl + '/' + roomname;\n    _this.url = serverUrl + '/' + roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams);\n    _this.roomname = roomname;\n    _this.doc = doc;\n    _this._WS = WebSocketPolyfill;\n    _this.awareness = awareness;\n    _this.wsconnected = false;\n    _this.wsconnecting = false;\n    _this.bcconnected = false;\n    _this.wsUnsuccessfulReconnects = 0;\n    _this.messageHandlers = messageHandlers.slice();\n    _this.mux = mutex.createMutex();\n    /**\n     * @type {boolean}\n     */\n\n    _this._synced = false;\n    /**\n     * @type {WebSocket?}\n     */\n\n    _this.ws = null;\n    _this.wsLastMessageReceived = 0;\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n\n    _this.shouldConnect = connect;\n    /**\n     * @type {number}\n     */\n\n    _this._resyncInterval = 0;\n\n    if (resyncInterval > 0) {\n      _this._resyncInterval =\n      /** @type {any} */\n      setInterval(function () {\n        if (_this.ws) {\n          // resend sync step 1\n          var encoder = encoding.createEncoder();\n          encoding.writeVarUint(encoder, messageSync);\n          syncProtocol.writeSyncStep1(encoder, doc);\n\n          _this.ws.send(encoding.toUint8Array(encoder));\n        }\n      }, resyncInterval);\n    }\n    /**\n     * @param {ArrayBuffer} data\n     */\n\n\n    _this._bcSubscriber = function (data) {\n      _this.mux(function () {\n        var encoder = readMessage(_assertThisInitialized(_this), new Uint8Array(data), false);\n\n        if (encoding.length(encoder) > 1) {\n          bc.publish(_this.bcChannel, encoding.toUint8Array(encoder));\n        }\n      });\n    };\n    /**\n     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n\n\n    _this._updateHandler = function (update, origin) {\n      if (origin !== _assertThisInitialized(_this) || origin === null) {\n        var encoder = encoding.createEncoder();\n        encoding.writeVarUint(encoder, messageSync);\n        syncProtocol.writeUpdate(encoder, update);\n        broadcastMessage(_assertThisInitialized(_this), encoding.toUint8Array(encoder));\n      }\n    };\n\n    _this.doc.on('update', _this._updateHandler);\n    /**\n     * @param {any} changed\n     * @param {any} origin\n     */\n\n\n    _this._awarenessUpdateHandler = function (_ref2, origin) {\n      var added = _ref2.added,\n          updated = _ref2.updated,\n          removed = _ref2.removed;\n      var changedClients = added.concat(updated).concat(removed);\n      var encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageAwareness);\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, changedClients));\n      broadcastMessage(_assertThisInitialized(_this), encoding.toUint8Array(encoder));\n    };\n\n    window.addEventListener('beforeunload', function () {\n      awarenessProtocol.removeAwarenessStates(_this.awareness, [doc.clientID], 'window unload');\n    });\n    awareness.on('update', _this._awarenessUpdateHandler);\n    _this._checkInterval =\n    /** @type {any} */\n    setInterval(function () {\n      if (_this.wsconnected && messageReconnectTimeout < time.getUnixTime() - _this.wsLastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n\n        /** @type {WebSocket} */\n        _this.ws.close();\n      }\n    }, messageReconnectTimeout / 10);\n\n    if (connect) {\n      _this.connect();\n    }\n\n    return _this;\n  }\n  /**\n   * @type {boolean}\n   */\n\n\n  _createClass(WebsocketProvider, [{\n    key: \"synced\",\n    get: function get() {\n      return this._synced;\n    },\n    set: function set(state) {\n      if (this._synced !== state) {\n        this._synced = state;\n        this.emit('synced', [state]);\n        this.emit('sync', [state]);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._resyncInterval !== 0) {\n        clearInterval(this._resyncInterval);\n      }\n\n      clearInterval(this._checkInterval);\n      this.disconnect();\n      this.awareness.off('update', this._awarenessUpdateHandler);\n      this.doc.off('update', this._updateHandler);\n\n      _get(_getPrototypeOf(WebsocketProvider.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"connectBc\",\n    value: function connectBc() {\n      var _this2 = this;\n\n      if (!this.bcconnected) {\n        bc.subscribe(this.bcChannel, this._bcSubscriber);\n        this.bcconnected = true;\n      } // send sync step1 to bc\n\n\n      this.mux(function () {\n        // write sync step 1\n        var encoderSync = encoding.createEncoder();\n        encoding.writeVarUint(encoderSync, messageSync);\n        syncProtocol.writeSyncStep1(encoderSync, _this2.doc);\n        bc.publish(_this2.bcChannel, encoding.toUint8Array(encoderSync)); // broadcast local state\n\n        var encoderState = encoding.createEncoder();\n        encoding.writeVarUint(encoderState, messageSync);\n        syncProtocol.writeSyncStep2(encoderState, _this2.doc);\n        bc.publish(_this2.bcChannel, encoding.toUint8Array(encoderState)); // write queryAwareness\n\n        var encoderAwarenessQuery = encoding.createEncoder();\n        encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness);\n        bc.publish(_this2.bcChannel, encoding.toUint8Array(encoderAwarenessQuery)); // broadcast local awareness state\n\n        var encoderAwarenessState = encoding.createEncoder();\n        encoding.writeVarUint(encoderAwarenessState, messageAwareness);\n        encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(_this2.awareness, [_this2.doc.clientID]));\n        bc.publish(_this2.bcChannel, encoding.toUint8Array(encoderAwarenessState));\n      });\n    }\n  }, {\n    key: \"disconnectBc\",\n    value: function disconnectBc() {\n      // broadcast message with local awareness state set to null (indicating disconnect)\n      var encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageAwareness);\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map()));\n      broadcastMessage(this, encoding.toUint8Array(encoder));\n\n      if (this.bcconnected) {\n        bc.unsubscribe(this.bcChannel, this._bcSubscriber);\n        this.bcconnected = false;\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.shouldConnect = false;\n      this.disconnectBc();\n\n      if (this.ws !== null) {\n        this.ws.close();\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.shouldConnect = true;\n\n      if (!this.wsconnected && this.ws === null) {\n        setupWS(this);\n        this.connectBc();\n      }\n    }\n  }]);\n\n  return WebsocketProvider;\n}(Observable);","map":{"version":3,"sources":["/media/neel/DATA/WebD/Smart Doc/client/node_modules/y-websocket/src/y-websocket.js"],"names":["Y","bc","time","encoding","decoding","syncProtocol","authProtocol","awarenessProtocol","mutex","Observable","math","url","messageSync","messageQueryAwareness","messageAwareness","messageAuth","messageHandlers","encoder","decoder","provider","emitSynced","messageType","writeVarUint","syncMessageType","readSyncMessage","doc","messageYjsSyncStep2","synced","writeVarUint8Array","encodeAwarenessUpdate","awareness","Array","from","getStates","keys","applyAwarenessUpdate","readVarUint8Array","readAuthMessage","permissionDeniedHandler","reconnectTimeoutBase","maxReconnectTimeout","messageReconnectTimeout","reason","console","warn","readMessage","buf","createDecoder","createEncoder","readVarUint","messageHandler","error","setupWS","shouldConnect","ws","websocket","_WS","binaryType","wsconnecting","wsconnected","onmessage","event","wsLastMessageReceived","getUnixTime","Uint8Array","data","length","send","toUint8Array","onclose","removeAwarenessStates","filter","client","clientID","emit","status","wsUnsuccessfulReconnects","setTimeout","min","log10","onopen","writeSyncStep1","getLocalState","encoderAwarenessState","broadcastMessage","bcconnected","mux","publish","bcChannel","WebsocketProvider","serverUrl","roomname","connect","Awareness","params","WebSocketPolyfill","WebSocket","resyncInterval","slice","encodedParams","encodeQueryParams","createMutex","_synced","_resyncInterval","setInterval","_bcSubscriber","_updateHandler","update","origin","writeUpdate","on","_awarenessUpdateHandler","added","updated","removed","changedClients","concat","window","addEventListener","_checkInterval","close","state","clearInterval","disconnect","off","subscribe","encoderSync","encoderState","writeSyncStep2","encoderAwarenessQuery","Map","unsubscribe","disconnectBc","connectBc"],"mappings":"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","sourcesContent":["/*\nUnlike stated in the LICENSE file, it is not necessary to include the copyright notice and permission notice when you copy code from this file.\n*/\n\n/**\n * @module provider/websocket\n */\n\n/* eslint-env browser */\n\nimport * as Y from 'yjs' // eslint-disable-line\nimport * as bc from 'lib0/broadcastchannel.js'\nimport * as time from 'lib0/time.js'\nimport * as encoding from 'lib0/encoding.js'\nimport * as decoding from 'lib0/decoding.js'\nimport * as syncProtocol from 'y-protocols/sync.js'\nimport * as authProtocol from 'y-protocols/auth.js'\nimport * as awarenessProtocol from 'y-protocols/awareness.js'\nimport * as mutex from 'lib0/mutex.js'\nimport { Observable } from 'lib0/observable.js'\nimport * as math from 'lib0/math.js'\nimport * as url from 'lib0/url.js'\n\nconst messageSync = 0\nconst messageQueryAwareness = 3\nconst messageAwareness = 1\nconst messageAuth = 2\n\n/**\n *                       encoder,          decoder,          provider,          emitSynced, messageType\n * @type {Array<function(encoding.Encoder, decoding.Decoder, WebsocketProvider, boolean,    number):void>}\n */\nconst messageHandlers = []\n\nmessageHandlers[messageSync] = (encoder, decoder, provider, emitSynced, messageType) => {\n  encoding.writeVarUint(encoder, messageSync)\n  const syncMessageType = syncProtocol.readSyncMessage(decoder, encoder, provider.doc, provider)\n  if (emitSynced && syncMessageType === syncProtocol.messageYjsSyncStep2 && !provider.synced) {\n    provider.synced = true\n  }\n}\n\nmessageHandlers[messageQueryAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {\n  encoding.writeVarUint(encoder, messageAwareness)\n  encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())))\n}\n\nmessageHandlers[messageAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {\n  awarenessProtocol.applyAwarenessUpdate(provider.awareness, decoding.readVarUint8Array(decoder), provider)\n}\n\nmessageHandlers[messageAuth] = (encoder, decoder, provider, emitSynced, messageType) => {\n  authProtocol.readAuthMessage(decoder, provider.doc, permissionDeniedHandler)\n}\n\nconst reconnectTimeoutBase = 1200\nconst maxReconnectTimeout = 2500\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000\n\n/**\n * @param {WebsocketProvider} provider\n * @param {string} reason\n */\nconst permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.\\n${reason}`)\n\n/**\n * @param {WebsocketProvider} provider\n * @param {Uint8Array} buf\n * @param {boolean} emitSynced\n * @return {encoding.Encoder}\n */\nconst readMessage = (provider, buf, emitSynced) => {\n  const decoder = decoding.createDecoder(buf)\n  const encoder = encoding.createEncoder()\n  const messageType = decoding.readVarUint(decoder)\n  const messageHandler = provider.messageHandlers[messageType]\n  if (/** @type {any} */ (messageHandler)) {\n    messageHandler(encoder, decoder, provider, emitSynced, messageType)\n  } else {\n    console.error('Unable to compute message')\n  }\n  return encoder\n}\n\n/**\n * @param {WebsocketProvider} provider\n */\nconst setupWS = provider => {\n  if (provider.shouldConnect && provider.ws === null) {\n    const websocket = new provider._WS(provider.url)\n    websocket.binaryType = 'arraybuffer'\n    provider.ws = websocket\n    provider.wsconnecting = true\n    provider.wsconnected = false\n    provider.synced = false\n\n    websocket.onmessage = event => {\n      provider.wsLastMessageReceived = time.getUnixTime()\n      const encoder = readMessage(provider, new Uint8Array(event.data), true)\n      if (encoding.length(encoder) > 1) {\n        websocket.send(encoding.toUint8Array(encoder))\n      }\n    }\n    websocket.onclose = () => {\n      provider.ws = null\n      provider.wsconnecting = false\n      if (provider.wsconnected) {\n        provider.wsconnected = false\n        provider.synced = false\n        // update awareness (all users except local left)\n        awarenessProtocol.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter(client => client !== provider.doc.clientID), provider)\n        provider.emit('status', [{\n          status: 'disconnected'\n        }])\n      } else {\n        provider.wsUnsuccessfulReconnects++\n      }\n      // Start with no reconnect timeout and increase timeout by\n      // log10(wsUnsuccessfulReconnects).\n      // The idea is to increase reconnect timeout slowly and have no reconnect\n      // timeout at the beginning (log(1) = 0)\n      setTimeout(setupWS, math.min(math.log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider)\n    }\n    websocket.onopen = () => {\n      provider.wsLastMessageReceived = time.getUnixTime()\n      provider.wsconnecting = false\n      provider.wsconnected = true\n      provider.wsUnsuccessfulReconnects = 0\n      provider.emit('status', [{\n        status: 'connected'\n      }])\n      // always send sync step 1 when connected\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageSync)\n      syncProtocol.writeSyncStep1(encoder, provider.doc)\n      websocket.send(encoding.toUint8Array(encoder))\n      // broadcast local awareness state\n      if (provider.awareness.getLocalState() !== null) {\n        const encoderAwarenessState = encoding.createEncoder()\n        encoding.writeVarUint(encoderAwarenessState, messageAwareness)\n        encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID]))\n        websocket.send(encoding.toUint8Array(encoderAwarenessState))\n      }\n    }\n\n    provider.emit('status', [{\n      status: 'connecting'\n    }])\n  }\n}\n\n/**\n * @param {WebsocketProvider} provider\n * @param {ArrayBuffer} buf\n */\nconst broadcastMessage = (provider, buf) => {\n  if (provider.wsconnected) {\n    // @ts-ignore We know that wsconnected = true\n    provider.ws.send(buf)\n  }\n  if (provider.bcconnected) {\n    provider.mux(() => {\n      bc.publish(provider.bcChannel, buf)\n    })\n  }\n}\n\n/**\n * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.\n * The document name is attached to the provided url. I.e. the following example\n * creates a websocket connection to http://localhost:1234/my-document-name\n *\n * @example\n *   import * as Y from 'yjs'\n *   import { WebsocketProvider } from 'y-websocket'\n *   const doc = new Y.Doc()\n *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)\n *\n * @extends {Observable<string>}\n */\nexport class WebsocketProvider extends Observable {\n  /**\n   * @param {string} serverUrl\n   * @param {string} roomname\n   * @param {Y.Doc} doc\n   * @param {object} [opts]\n   * @param {boolean} [opts.connect]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {Object<string,string>} [opts.params]\n   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill\n   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds\n   */\n  constructor (serverUrl, roomname, doc, { connect = true, awareness = new awarenessProtocol.Awareness(doc), params = {}, WebSocketPolyfill = WebSocket, resyncInterval = -1 } = {}) {\n    super()\n    // ensure that url is always ends with /\n    while (serverUrl[serverUrl.length - 1] === '/') {\n      serverUrl = serverUrl.slice(0, serverUrl.length - 1)\n    }\n    const encodedParams = url.encodeQueryParams(params)\n    this.bcChannel = serverUrl + '/' + roomname\n    this.url = serverUrl + '/' + roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams)\n    this.roomname = roomname\n    this.doc = doc\n    this._WS = WebSocketPolyfill\n    this.awareness = awareness\n    this.wsconnected = false\n    this.wsconnecting = false\n    this.bcconnected = false\n    this.wsUnsuccessfulReconnects = 0\n    this.messageHandlers = messageHandlers.slice()\n    this.mux = mutex.createMutex()\n    /**\n     * @type {boolean}\n     */\n    this._synced = false\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null\n    this.wsLastMessageReceived = 0\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = connect\n\n    /**\n     * @type {number}\n     */\n    this._resyncInterval = 0\n    if (resyncInterval > 0) {\n      this._resyncInterval = /** @type {any} */ (setInterval(() => {\n        if (this.ws) {\n          // resend sync step 1\n          const encoder = encoding.createEncoder()\n          encoding.writeVarUint(encoder, messageSync)\n          syncProtocol.writeSyncStep1(encoder, doc)\n          this.ws.send(encoding.toUint8Array(encoder))\n        }\n      }, resyncInterval))\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     */\n    this._bcSubscriber = data => {\n      this.mux(() => {\n        const encoder = readMessage(this, new Uint8Array(data), false)\n        if (encoding.length(encoder) > 1) {\n          bc.publish(this.bcChannel, encoding.toUint8Array(encoder))\n        }\n      })\n    }\n    /**\n     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._updateHandler = (update, origin) => {\n      if (origin !== this || origin === null) {\n        const encoder = encoding.createEncoder()\n        encoding.writeVarUint(encoder, messageSync)\n        syncProtocol.writeUpdate(encoder, update)\n        broadcastMessage(this, encoding.toUint8Array(encoder))\n      }\n    }\n    this.doc.on('update', this._updateHandler)\n    /**\n     * @param {any} changed\n     * @param {any} origin\n     */\n    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {\n      const changedClients = added.concat(updated).concat(removed)\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageAwareness)\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, changedClients))\n      broadcastMessage(this, encoding.toUint8Array(encoder))\n    }\n    window.addEventListener('beforeunload', () => {\n      awarenessProtocol.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload')\n    })\n    awareness.on('update', this._awarenessUpdateHandler)\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      if (this.wsconnected && messageReconnectTimeout < time.getUnixTime() - this.wsLastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */ (this.ws).close()\n      }\n    }, messageReconnectTimeout / 10))\n    if (connect) {\n      this.connect()\n    }\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get synced () {\n    return this._synced\n  }\n\n  set synced (state) {\n    if (this._synced !== state) {\n      this._synced = state\n      this.emit('synced', [state])\n      this.emit('sync', [state])\n    }\n  }\n\n  destroy () {\n    if (this._resyncInterval !== 0) {\n      clearInterval(this._resyncInterval)\n    }\n    clearInterval(this._checkInterval)\n    this.disconnect()\n    this.awareness.off('update', this._awarenessUpdateHandler)\n    this.doc.off('update', this._updateHandler)\n    super.destroy()\n  }\n\n  connectBc () {\n    if (!this.bcconnected) {\n      bc.subscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = true\n    }\n    // send sync step1 to bc\n    this.mux(() => {\n      // write sync step 1\n      const encoderSync = encoding.createEncoder()\n      encoding.writeVarUint(encoderSync, messageSync)\n      syncProtocol.writeSyncStep1(encoderSync, this.doc)\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderSync))\n      // broadcast local state\n      const encoderState = encoding.createEncoder()\n      encoding.writeVarUint(encoderState, messageSync)\n      syncProtocol.writeSyncStep2(encoderState, this.doc)\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderState))\n      // write queryAwareness\n      const encoderAwarenessQuery = encoding.createEncoder()\n      encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderAwarenessQuery))\n      // broadcast local awareness state\n      const encoderAwarenessState = encoding.createEncoder()\n      encoding.writeVarUint(encoderAwarenessState, messageAwareness)\n      encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))\n      bc.publish(this.bcChannel, encoding.toUint8Array(encoderAwarenessState))\n    })\n  }\n\n  disconnectBc () {\n    // broadcast message with local awareness state set to null (indicating disconnect)\n    const encoder = encoding.createEncoder()\n    encoding.writeVarUint(encoder, messageAwareness)\n    encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map()))\n    broadcastMessage(this, encoding.toUint8Array(encoder))\n    if (this.bcconnected) {\n      bc.unsubscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = false\n    }\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    this.disconnectBc()\n    if (this.ws !== null) {\n      this.ws.close()\n    }\n  }\n\n  connect () {\n    this.shouldConnect = true\n    if (!this.wsconnected && this.ws === null) {\n      setupWS(this)\n      this.connectBc()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}