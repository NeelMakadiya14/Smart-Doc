{"ast":null,"code":"/**\n * @module sync-protocol\n */\nimport * as encoding from 'lib0/encoding.js';\nimport * as decoding from 'lib0/decoding.js';\nimport * as Y from 'yjs';\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport var messageYjsSyncStep1 = 0;\nexport var messageYjsSyncStep2 = 1;\nexport var messageYjsUpdate = 2;\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\n\nexport var writeSyncStep1 = function writeSyncStep1(encoder, doc) {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1);\n  var sv = Y.encodeStateVector(doc);\n  encoding.writeVarUint8Array(encoder, sv);\n};\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\n\nexport var writeSyncStep2 = function writeSyncStep2(encoder, doc, encodedStateVector) {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2);\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector));\n};\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\n\nexport var readSyncStep1 = function readSyncStep1(decoder, encoder, doc) {\n  return writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder));\n};\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\n\nexport var readSyncStep2 = function readSyncStep2(decoder, doc, transactionOrigin) {\n  try {\n    Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin);\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error);\n  }\n};\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\n\nexport var writeUpdate = function writeUpdate(encoder, update) {\n  encoding.writeVarUint(encoder, messageYjsUpdate);\n  encoding.writeVarUint8Array(encoder, update);\n};\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\n\nexport var readUpdate = readSyncStep2;\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\n\nexport var readSyncMessage = function readSyncMessage(decoder, encoder, doc, transactionOrigin) {\n  var messageType = decoding.readVarUint(decoder);\n\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc);\n      break;\n\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin);\n      break;\n\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin);\n      break;\n\n    default:\n      throw new Error('Unknown message type');\n  }\n\n  return messageType;\n};","map":{"version":3,"sources":["/media/neel/DATA/WebD/Smart Doc/client/node_modules/y-protocols/sync.js"],"names":["encoding","decoding","Y","messageYjsSyncStep1","messageYjsSyncStep2","messageYjsUpdate","writeSyncStep1","encoder","doc","writeVarUint","sv","encodeStateVector","writeVarUint8Array","writeSyncStep2","encodedStateVector","encodeStateAsUpdate","readSyncStep1","decoder","readVarUint8Array","readSyncStep2","transactionOrigin","applyUpdate","error","console","writeUpdate","update","readUpdate","readSyncMessage","messageType","readVarUint","Error"],"mappings":"AAAA;AACA;AACA;AAEA,OAAO,KAAKA,QAAZ,MAA0B,kBAA1B;AACA,OAAO,KAAKC,QAAZ,MAA0B,kBAA1B;AACA,OAAO,KAAKC,CAAZ,MAAmB,KAAnB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAMC,mBAAmB,GAAG,CAA5B;AACP,OAAO,IAAMC,mBAAmB,GAAG,CAA5B;AACP,OAAO,IAAMC,gBAAgB,GAAG,CAAzB;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACC,OAAD,EAAUC,GAAV,EAAkB;AAC9CR,EAAAA,QAAQ,CAACS,YAAT,CAAsBF,OAAtB,EAA+BJ,mBAA/B;AACA,MAAMO,EAAE,GAAGR,CAAC,CAACS,iBAAF,CAAoBH,GAApB,CAAX;AACAR,EAAAA,QAAQ,CAACY,kBAAT,CAA4BL,OAA5B,EAAqCG,EAArC;AACD,CAJM;AAMP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMG,cAAc,GAAG,SAAjBA,cAAiB,CAACN,OAAD,EAAUC,GAAV,EAAeM,kBAAf,EAAsC;AAClEd,EAAAA,QAAQ,CAACS,YAAT,CAAsBF,OAAtB,EAA+BH,mBAA/B;AACAJ,EAAAA,QAAQ,CAACY,kBAAT,CAA4BL,OAA5B,EAAqCL,CAAC,CAACa,mBAAF,CAAsBP,GAAtB,EAA2BM,kBAA3B,CAArC;AACD,CAHM;AAKP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAME,aAAa,GAAG,SAAhBA,aAAgB,CAACC,OAAD,EAAUV,OAAV,EAAmBC,GAAnB;AAAA,SAC3BK,cAAc,CAACN,OAAD,EAAUC,GAAV,EAAeP,QAAQ,CAACiB,iBAAT,CAA2BD,OAA3B,CAAf,CADa;AAAA,CAAtB;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAME,aAAa,GAAG,SAAhBA,aAAgB,CAACF,OAAD,EAAUT,GAAV,EAAeY,iBAAf,EAAqC;AAChE,MAAI;AACFlB,IAAAA,CAAC,CAACmB,WAAF,CAAcb,GAAd,EAAmBP,QAAQ,CAACiB,iBAAT,CAA2BD,OAA3B,CAAnB,EAAwDG,iBAAxD;AACD,GAFD,CAEE,OAAOE,KAAP,EAAc;AACd;AACAC,IAAAA,OAAO,CAACD,KAAR,CAAc,0CAAd,EAA0DA,KAA1D;AACD;AACF,CAPM;AASP;AACA;AACA;AACA;;AACA,OAAO,IAAME,WAAW,GAAG,SAAdA,WAAc,CAACjB,OAAD,EAAUkB,MAAV,EAAqB;AAC9CzB,EAAAA,QAAQ,CAACS,YAAT,CAAsBF,OAAtB,EAA+BF,gBAA/B;AACAL,EAAAA,QAAQ,CAACY,kBAAT,CAA4BL,OAA5B,EAAqCkB,MAArC;AACD,CAHM;AAKP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,UAAU,GAAGP,aAAnB;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMQ,eAAe,GAAG,SAAlBA,eAAkB,CAACV,OAAD,EAAUV,OAAV,EAAmBC,GAAnB,EAAwBY,iBAAxB,EAA8C;AAC3E,MAAMQ,WAAW,GAAG3B,QAAQ,CAAC4B,WAAT,CAAqBZ,OAArB,CAApB;;AACA,UAAQW,WAAR;AACE,SAAKzB,mBAAL;AACEa,MAAAA,aAAa,CAACC,OAAD,EAAUV,OAAV,EAAmBC,GAAnB,CAAb;AACA;;AACF,SAAKJ,mBAAL;AACEe,MAAAA,aAAa,CAACF,OAAD,EAAUT,GAAV,EAAeY,iBAAf,CAAb;AACA;;AACF,SAAKf,gBAAL;AACEqB,MAAAA,UAAU,CAACT,OAAD,EAAUT,GAAV,EAAeY,iBAAf,CAAV;AACA;;AACF;AACE,YAAM,IAAIU,KAAJ,CAAU,sBAAV,CAAN;AAXJ;;AAaA,SAAOF,WAAP;AACD,CAhBM","sourcesContent":["/**\n * @module sync-protocol\n */\n\nimport * as encoding from 'lib0/encoding.js'\nimport * as decoding from 'lib0/decoding.js'\nimport * as Y from 'yjs'\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport const messageYjsSyncStep1 = 0\nexport const messageYjsSyncStep2 = 1\nexport const messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nexport const writeSyncStep1 = (encoder, doc) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = Y.encodeStateVector(doc)\n  encoding.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nexport const writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2)\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nexport const readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin)\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error)\n  }\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nexport const writeUpdate = (encoder, update) => {\n  encoding.writeVarUint(encoder, messageYjsUpdate)\n  encoding.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = decoding.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n}\n"]},"metadata":{},"sourceType":"module"}