{"ast":null,"code":"import _toConsumableArray from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * Observable class prototype.\n *\n * @module observable\n */\nimport * as map from './map.js';\nimport * as set from './set.js';\nimport * as array from './array.js';\n/**\n * Handles named events.\n *\n * @template N\n */\n\nexport var Observable = /*#__PURE__*/function () {\n  function Observable() {\n    _classCallCheck(this, Observable);\n\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create();\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n\n\n  _createClass(Observable, [{\n    key: \"on\",\n    value: function on(name, f) {\n      map.setIfUndefined(this._observers, name, set.create).add(f);\n    }\n    /**\n     * @param {N} name\n     * @param {function} f\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(name, f) {\n      var _this = this;\n\n      /**\n       * @param  {...any} args\n       */\n      var _f = function _f() {\n        _this.off(name, _f);\n\n        f.apply(void 0, arguments);\n      };\n\n      this.on(name, _f);\n    }\n    /**\n     * @param {N} name\n     * @param {function} f\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(name, f) {\n      var observers = this._observers.get(name);\n\n      if (observers !== undefined) {\n        observers.delete(f);\n\n        if (observers.size === 0) {\n          this._observers.delete(name);\n        }\n      }\n    }\n    /**\n     * Emit a named event. All registered event listeners that listen to the\n     * specified name will receive the event.\n     *\n     * @todo This should catch exceptions\n     *\n     * @param {N} name The event name.\n     * @param {Array<any>} args The arguments that are applied to the event listener.\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(name, args) {\n      // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n      return array.from((this._observers.get(name) || map.create()).values()).forEach(function (f) {\n        return f.apply(void 0, _toConsumableArray(args));\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._observers = map.create();\n    }\n  }]);\n\n  return Observable;\n}();","map":{"version":3,"sources":["/media/neel/DATA/WebD/Smart Doc/client/node_modules/lib0/observable.js"],"names":["map","set","array","Observable","_observers","create","name","f","setIfUndefined","add","_f","off","on","observers","get","undefined","delete","size","args","from","values","forEach"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AAEA,OAAO,KAAKA,GAAZ,MAAqB,UAArB;AACA,OAAO,KAAKC,GAAZ,MAAqB,UAArB;AACA,OAAO,KAAKC,KAAZ,MAAuB,YAAvB;AAEA;AACA;AACA;AACA;AACA;;AACA,WAAaC,UAAb;AACE,wBAAe;AAAA;;AACb;AACJ;AACA;AACA;AACI,SAAKC,UAAL,GAAkBJ,GAAG,CAACK,MAAJ,EAAlB;AACD;AAED;AACF;AACA;AACA;;;AAZA;AAAA;AAAA,WAaE,YAAIC,IAAJ,EAAUC,CAAV,EAAa;AACXP,MAAAA,GAAG,CAACQ,cAAJ,CAAmB,KAAKJ,UAAxB,EAAoCE,IAApC,EAA0CL,GAAG,CAACI,MAA9C,EAAsDI,GAAtD,CAA0DF,CAA1D;AACD;AAED;AACF;AACA;AACA;;AApBA;AAAA;AAAA,WAqBE,cAAMD,IAAN,EAAYC,CAAZ,EAAe;AAAA;;AACb;AACJ;AACA;AACI,UAAMG,EAAE,GAAG,SAALA,EAAK,GAAa;AACtB,QAAA,KAAI,CAACC,GAAL,CAASL,IAAT,EAAeI,EAAf;;AACAH,QAAAA,CAAC,MAAD;AACD,OAHD;;AAIA,WAAKK,EAAL,CAAQN,IAAR,EAAcI,EAAd;AACD;AAED;AACF;AACA;AACA;;AAnCA;AAAA;AAAA,WAoCE,aAAKJ,IAAL,EAAWC,CAAX,EAAc;AACZ,UAAMM,SAAS,GAAG,KAAKT,UAAL,CAAgBU,GAAhB,CAAoBR,IAApB,CAAlB;;AACA,UAAIO,SAAS,KAAKE,SAAlB,EAA6B;AAC3BF,QAAAA,SAAS,CAACG,MAAV,CAAiBT,CAAjB;;AACA,YAAIM,SAAS,CAACI,IAAV,KAAmB,CAAvB,EAA0B;AACxB,eAAKb,UAAL,CAAgBY,MAAhB,CAAuBV,IAAvB;AACD;AACF;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtDA;AAAA;AAAA,WAuDE,cAAMA,IAAN,EAAYY,IAAZ,EAAkB;AAChB;AACA,aAAOhB,KAAK,CAACiB,IAAN,CAAW,CAAC,KAAKf,UAAL,CAAgBU,GAAhB,CAAoBR,IAApB,KAA6BN,GAAG,CAACK,MAAJ,EAA9B,EAA4Ce,MAA5C,EAAX,EAAiEC,OAAjE,CAAyE,UAAAd,CAAC;AAAA,eAAIA,CAAC,MAAD,4BAAKW,IAAL,EAAJ;AAAA,OAA1E,CAAP;AACD;AA1DH;AAAA;AAAA,WA4DE,mBAAW;AACT,WAAKd,UAAL,GAAkBJ,GAAG,CAACK,MAAJ,EAAlB;AACD;AA9DH;;AAAA;AAAA","sourcesContent":["/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n *\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}