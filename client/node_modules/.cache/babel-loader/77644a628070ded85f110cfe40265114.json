{"ast":null,"code":"import _classCallCheck from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @module awareness-protocol\n */\nimport * as encoding from 'lib0/encoding.js';\nimport * as decoding from 'lib0/decoding.js';\nimport * as time from 'lib0/time.js';\nimport * as math from 'lib0/math.js';\nimport { Observable } from 'lib0/observable.js';\nimport * as f from 'lib0/function.js';\nimport * as Y from 'yjs'; // eslint-disable-line\n\nexport var outdatedTimeout = 30000;\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\n\nexport var Awareness = /*#__PURE__*/function (_Observable) {\n  _inherits(Awareness, _Observable);\n\n  var _super = _createSuper(Awareness);\n\n  /**\n   * @param {Y.Doc} doc\n   */\n  function Awareness(doc) {\n    var _this;\n\n    _classCallCheck(this, Awareness);\n\n    _this = _super.call(this);\n    _this.doc = doc;\n    /**\n     * @type {number}\n     */\n\n    _this.clientID = doc.clientID;\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n\n    _this.states = new Map();\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n\n    _this.meta = new Map();\n    _this._checkInterval =\n    /** @type {any} */\n    setInterval(function () {\n      var now = time.getUnixTime();\n\n      if (_this.getLocalState() !== null && outdatedTimeout / 2 <= now -\n      /** @type {{lastUpdated:number}} */\n      _this.meta.get(_this.clientID).lastUpdated) {\n        // renew local clock\n        _this.setLocalState(_this.getLocalState());\n      }\n      /**\n       * @type {Array<number>}\n       */\n\n\n      var remove = [];\n\n      _this.meta.forEach(function (meta, clientid) {\n        if (clientid !== _this.clientID && outdatedTimeout <= now - meta.lastUpdated && _this.states.has(clientid)) {\n          remove.push(clientid);\n        }\n      });\n\n      if (remove.length > 0) {\n        removeAwarenessStates(_assertThisInitialized(_this), remove, 'timeout');\n      }\n    }, math.floor(outdatedTimeout / 10));\n    doc.on('destroy', function () {\n      _this.destroy();\n    });\n\n    _this.setLocalState({});\n\n    return _this;\n  }\n\n  _createClass(Awareness, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.emit('destroy', [this]);\n      this.setLocalState(null);\n\n      _get(_getPrototypeOf(Awareness.prototype), \"destroy\", this).call(this);\n\n      clearInterval(this._checkInterval);\n    }\n    /**\n     * @return {Object<string,any>|null}\n     */\n\n  }, {\n    key: \"getLocalState\",\n    value: function getLocalState() {\n      return this.states.get(this.clientID) || null;\n    }\n    /**\n     * @param {Object<string,any>|null} state\n     */\n\n  }, {\n    key: \"setLocalState\",\n    value: function setLocalState(state) {\n      var clientID = this.clientID;\n      var currLocalMeta = this.meta.get(clientID);\n      var clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;\n      var prevState = this.states.get(clientID);\n\n      if (state === null) {\n        this.states.delete(clientID);\n      } else {\n        this.states.set(clientID, state);\n      }\n\n      this.meta.set(clientID, {\n        clock: clock,\n        lastUpdated: time.getUnixTime()\n      });\n      var added = [];\n      var updated = [];\n      var filteredUpdated = [];\n      var removed = [];\n\n      if (state === null) {\n        removed.push(clientID);\n      } else if (prevState == null) {\n        if (state != null) {\n          added.push(clientID);\n        }\n      } else {\n        updated.push(clientID);\n\n        if (!f.equalityDeep(prevState, state)) {\n          filteredUpdated.push(clientID);\n        }\n      }\n\n      if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n        this.emit('change', [{\n          added: added,\n          updated: filteredUpdated,\n          removed: removed\n        }, 'local']);\n      }\n\n      this.emit('update', [{\n        added: added,\n        updated: updated,\n        removed: removed\n      }, 'local']);\n    }\n    /**\n     * @param {string} field\n     * @param {any} value\n     */\n\n  }, {\n    key: \"setLocalStateField\",\n    value: function setLocalStateField(field, value) {\n      var state = this.getLocalState();\n\n      if (state !== null) {\n        state[field] = value;\n        this.setLocalState(state);\n      }\n    }\n    /**\n     * @return {Map<number,Object<string,any>>}\n     */\n\n  }, {\n    key: \"getStates\",\n    value: function getStates() {\n      return this.states;\n    }\n  }]);\n\n  return Awareness;\n}(Observable);\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\n\nexport var removeAwarenessStates = function removeAwarenessStates(awareness, clients, origin) {\n  var removed = [];\n\n  for (var i = 0; i < clients.length; i++) {\n    var clientID = clients[i];\n\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID);\n\n      if (clientID === awareness.clientID) {\n        var curMeta =\n        /** @type {MetaClientState} */\n        awareness.meta.get(clientID);\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        });\n      }\n\n      removed.push(clientID);\n    }\n  }\n\n  if (removed.length > 0) {\n    awareness.emit('change', [{\n      added: [],\n      updated: [],\n      removed: removed\n    }, origin]);\n    awareness.emit('update', [{\n      added: [],\n      updated: [],\n      removed: removed\n    }, origin]);\n  }\n};\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\n\nexport var encodeAwarenessUpdate = function encodeAwarenessUpdate(awareness, clients) {\n  var states = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : awareness.states;\n  var len = clients.length;\n  var encoder = encoding.createEncoder();\n  encoding.writeVarUint(encoder, len);\n\n  for (var i = 0; i < len; i++) {\n    var clientID = clients[i];\n    var state = states.get(clientID) || null;\n    var clock =\n    /** @type {MetaClientState} */\n    awareness.meta.get(clientID).clock;\n    encoding.writeVarUint(encoder, clientID);\n    encoding.writeVarUint(encoder, clock);\n    encoding.writeVarString(encoder, JSON.stringify(state));\n  }\n\n  return encoding.toUint8Array(encoder);\n};\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\n\nexport var modifyAwarenessUpdate = function modifyAwarenessUpdate(update, modify) {\n  var decoder = decoding.createDecoder(update);\n  var encoder = encoding.createEncoder();\n  var len = decoding.readVarUint(decoder);\n  encoding.writeVarUint(encoder, len);\n\n  for (var i = 0; i < len; i++) {\n    var clientID = decoding.readVarUint(decoder);\n    var clock = decoding.readVarUint(decoder);\n    var state = JSON.parse(decoding.readVarString(decoder));\n    var modifiedState = modify(state);\n    encoding.writeVarUint(encoder, clientID);\n    encoding.writeVarUint(encoder, clock);\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState));\n  }\n\n  return encoding.toUint8Array(encoder);\n};\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\n\nexport var applyAwarenessUpdate = function applyAwarenessUpdate(awareness, update, origin) {\n  var decoder = decoding.createDecoder(update);\n  var timestamp = time.getUnixTime();\n  var added = [];\n  var updated = [];\n  var filteredUpdated = [];\n  var removed = [];\n  var len = decoding.readVarUint(decoder);\n\n  for (var i = 0; i < len; i++) {\n    var clientID = decoding.readVarUint(decoder);\n    var clock = decoding.readVarUint(decoder);\n    var state = JSON.parse(decoding.readVarString(decoder));\n    var clientMeta = awareness.meta.get(clientID);\n    var prevState = awareness.states.get(clientID);\n    var currClock = clientMeta === undefined ? 0 : clientMeta.clock;\n\n    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++;\n        } else {\n          awareness.states.delete(clientID);\n        }\n      } else {\n        awareness.states.set(clientID, state);\n      }\n\n      awareness.meta.set(clientID, {\n        clock: clock,\n        lastUpdated: timestamp\n      });\n\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID);\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID);\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID);\n        }\n\n        updated.push(clientID);\n      }\n    }\n  }\n\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added: added,\n      updated: filteredUpdated,\n      removed: removed\n    }, origin]);\n  }\n\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added: added,\n      updated: updated,\n      removed: removed\n    }, origin]);\n  }\n};","map":{"version":3,"sources":["/media/neel/DATA/WebD/Smart Doc/client/node_modules/y-protocols/awareness.js"],"names":["encoding","decoding","time","math","Observable","f","Y","outdatedTimeout","Awareness","doc","clientID","states","Map","meta","_checkInterval","setInterval","now","getUnixTime","getLocalState","get","lastUpdated","setLocalState","remove","forEach","clientid","has","push","length","removeAwarenessStates","floor","on","destroy","emit","clearInterval","state","currLocalMeta","clock","undefined","prevState","delete","set","added","updated","filteredUpdated","removed","equalityDeep","field","value","awareness","clients","origin","i","curMeta","encodeAwarenessUpdate","len","encoder","createEncoder","writeVarUint","writeVarString","JSON","stringify","toUint8Array","modifyAwarenessUpdate","update","modify","decoder","createDecoder","readVarUint","parse","readVarString","modifiedState","applyAwarenessUpdate","timestamp","clientMeta","currClock"],"mappings":"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","sourcesContent":["/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding.js'\nimport * as decoding from 'lib0/decoding.js'\nimport * as time from 'lib0/time.js'\nimport * as math from 'lib0/math.js'\nimport { Observable } from 'lib0/observable.js'\nimport * as f from 'lib0/function.js'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      state[field] = value\n      this.setLocalState(state)\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n"]},"metadata":{},"sourceType":"module"}