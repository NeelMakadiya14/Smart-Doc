{"ast":null,"code":"import _createClass from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\nimport * as buffer from './buffer.js';\nimport * as math from './math.js';\nimport * as number from './number.js';\nimport * as binary from './binary.js';\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\n\nexport var Encoder = function Encoder() {\n  _classCallCheck(this, Encoder);\n\n  this.cpos = 0;\n  this.cbuf = new Uint8Array(100);\n  /**\n   * @type {Array<Uint8Array>}\n   */\n\n  this.bufs = [];\n};\n/**\n * @function\n * @return {Encoder}\n */\n\nexport var createEncoder = function createEncoder() {\n  return new Encoder();\n};\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\n\nexport var length = function length(encoder) {\n  var len = encoder.cpos;\n\n  for (var i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n\n  return len;\n};\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\n\nvar _toUint8Array = function toUint8Array(encoder) {\n  var uint8arr = new Uint8Array(length(encoder));\n  var curPos = 0;\n\n  for (var i = 0; i < encoder.bufs.length; i++) {\n    var d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n\n  uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr;\n};\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\n\n\nexport { _toUint8Array as toUint8Array };\n\nvar verifyLen = function verifyLen(encoder, len) {\n  var bufferLen = encoder.cbuf.length;\n\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2);\n    encoder.cpos = 0;\n  }\n};\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\n\n\nexport var write = function write(encoder, num) {\n  var bufferLen = encoder.cbuf.length;\n\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n\n  encoder.cbuf[encoder.cpos++] = num;\n};\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\n\nexport var set = function set(encoder, pos, num) {\n  var buffer = null; // iterate all buffers and adjust position\n\n  for (var i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    var b = encoder.bufs[i];\n\n    if (pos < b.length) {\n      buffer = b; // found buffer\n    } else {\n      pos -= b.length;\n    }\n  }\n\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf;\n  }\n\n  buffer[pos] = num;\n};\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\n\nexport var writeUint8 = write;\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\n\nexport var setUint8 = set;\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\n\nexport var writeUint16 = function writeUint16(encoder, num) {\n  write(encoder, num & binary.BITS8);\n  write(encoder, num >>> 8 & binary.BITS8);\n};\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\n\nexport var setUint16 = function setUint16(encoder, pos, num) {\n  set(encoder, pos, num & binary.BITS8);\n  set(encoder, pos + 1, num >>> 8 & binary.BITS8);\n};\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\n\nexport var writeUint32 = function writeUint32(encoder, num) {\n  for (var i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8);\n    num >>>= 8;\n  }\n};\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\n\nexport var writeUint32BigEndian = function writeUint32BigEndian(encoder, num) {\n  for (var i = 3; i >= 0; i--) {\n    write(encoder, num >>> 8 * i & binary.BITS8);\n  }\n};\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\n\nexport var setUint32 = function setUint32(encoder, pos, num) {\n  for (var i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8);\n    num >>>= 8;\n  }\n};\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\n\nexport var writeVarUint = function writeVarUint(encoder, num) {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | binary.BITS7 & num);\n    num >>>= 7;\n  }\n\n  write(encoder, binary.BITS7 & num);\n};\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don't use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\n\nexport var writeVarInt = function writeVarInt(encoder, num) {\n  var isNegative = math.isNegativeZero(num);\n\n  if (isNegative) {\n    num = -num;\n  } //             |- whether to continue reading         |- whether is negative     |- number\n\n\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | binary.BITS6 & num);\n  num >>>= 6; // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | binary.BITS7 & num);\n    num >>>= 7;\n  }\n};\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n\nexport var writeVarString = function writeVarString(encoder, str) {\n  var encodedString = unescape(encodeURIComponent(str));\n  var len = encodedString.length;\n  writeVarUint(encoder, len);\n\n  for (var i = 0; i < len; i++) {\n    write(encoder,\n    /** @type {number} */\n    encodedString.codePointAt(i));\n  }\n};\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\n\nexport var writeBinaryEncoder = function writeBinaryEncoder(encoder, append) {\n  return writeUint8Array(encoder, _toUint8Array(append));\n};\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\n\nexport var writeUint8Array = function writeUint8Array(encoder, uint8Array) {\n  var bufferLen = encoder.cbuf.length;\n  var cpos = encoder.cpos;\n  var leftCopyLen = math.min(bufferLen - cpos, uint8Array.length);\n  var rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf); // must have at least size of remaining buffer\n\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen)); // copy array\n\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\n\nexport var writeVarUint8Array = function writeVarUint8Array(encoder, uint8Array) {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\n\nexport var writeOnDataView = function writeOnDataView(encoder, len) {\n  verifyLen(encoder, len);\n  var dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);\n  encoder.cpos += len;\n  return dview;\n};\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\n\nexport var writeFloat32 = function writeFloat32(encoder, num) {\n  return writeOnDataView(encoder, 4).setFloat32(0, num);\n};\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\n\nexport var writeFloat64 = function writeFloat64(encoder, num) {\n  return writeOnDataView(encoder, 8).setFloat64(0, num);\n};\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\n\nexport var writeBigInt64 = function writeBigInt64(encoder, num) {\n  return (\n    /** @type {any} */\n    writeOnDataView(encoder, 8).setBigInt64(0, num)\n  );\n};\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\n\nexport var writeBigUint64 = function writeBigUint64(encoder, num) {\n  return (\n    /** @type {any} */\n    writeOnDataView(encoder, 8).setBigUint64(0, num)\n  );\n};\nvar floatTestBed = new DataView(new ArrayBuffer(4));\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\n\nvar isFloat32 = function isFloat32(num) {\n  floatTestBed.setFloat32(0, num);\n  return floatTestBed.getFloat32(0) === num;\n};\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\n\n\nexport var writeAny = function writeAny(encoder, data) {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119);\n      writeVarString(encoder, data);\n      break;\n\n    case 'number':\n      if (number.isInteger(data) && data <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125);\n        writeVarInt(encoder, data);\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124);\n        writeFloat32(encoder, data);\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123);\n        writeFloat64(encoder, data);\n      }\n\n      break;\n\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122);\n      writeBigInt64(encoder, data);\n      break;\n\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126);\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117);\n        writeVarUint(encoder, data.length);\n\n        for (var i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i]);\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116);\n        writeVarUint8Array(encoder, data);\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118);\n        var keys = Object.keys(data);\n        writeVarUint(encoder, keys.length);\n\n        for (var _i = 0; _i < keys.length; _i++) {\n          var key = keys[_i];\n          writeVarString(encoder, key);\n          writeAny(encoder, data[key]);\n        }\n      }\n\n      break;\n\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121);\n      break;\n\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127);\n  }\n};\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\n\nexport var RleEncoder = /*#__PURE__*/function (_Encoder) {\n  _inherits(RleEncoder, _Encoder);\n\n  var _super = _createSuper(RleEncoder);\n\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  function RleEncoder(writer) {\n    var _this;\n\n    _classCallCheck(this, RleEncoder);\n\n    _this = _super.call(this);\n    /**\n     * The writer\n     */\n\n    _this.w = writer;\n    /**\n     * Current state\n     * @type {T|null}\n     */\n\n    _this.s = null;\n    _this.count = 0;\n    return _this;\n  }\n  /**\n   * @param {T} v\n   */\n\n\n  _createClass(RleEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.s === v) {\n        this.count++;\n      } else {\n        if (this.count > 0) {\n          // flush counter, unless this is the first value (count = 0)\n          writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw\n        }\n\n        this.count = 1; // write first value\n\n        this.w(this, v);\n        this.s = v;\n      }\n    }\n  }]);\n\n  return RleEncoder;\n}(Encoder);\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\n\nexport var IntDiffEncoder = /*#__PURE__*/function (_Encoder2) {\n  _inherits(IntDiffEncoder, _Encoder2);\n\n  var _super2 = _createSuper(IntDiffEncoder);\n\n  /**\n   * @param {number} start\n   */\n  function IntDiffEncoder(start) {\n    var _this2;\n\n    _classCallCheck(this, IntDiffEncoder);\n\n    _this2 = _super2.call(this);\n    /**\n     * Current state\n     * @type {number}\n     */\n\n    _this2.s = start;\n    return _this2;\n  }\n  /**\n   * @param {number} v\n   */\n\n\n  _createClass(IntDiffEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      writeVarInt(this, v - this.s);\n      this.s = v;\n    }\n  }]);\n\n  return IntDiffEncoder;\n}(Encoder);\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\n\nexport var RleIntDiffEncoder = /*#__PURE__*/function (_Encoder3) {\n  _inherits(RleIntDiffEncoder, _Encoder3);\n\n  var _super3 = _createSuper(RleIntDiffEncoder);\n\n  /**\n   * @param {number} start\n   */\n  function RleIntDiffEncoder(start) {\n    var _this3;\n\n    _classCallCheck(this, RleIntDiffEncoder);\n\n    _this3 = _super3.call(this);\n    /**\n     * Current state\n     * @type {number}\n     */\n\n    _this3.s = start;\n    _this3.count = 0;\n    return _this3;\n  }\n  /**\n   * @param {number} v\n   */\n\n\n  _createClass(RleIntDiffEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.s === v && this.count > 0) {\n        this.count++;\n      } else {\n        if (this.count > 0) {\n          // flush counter, unless this is the first value (count = 0)\n          writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw\n        }\n\n        this.count = 1; // write first value\n\n        writeVarInt(this, v - this.s);\n        this.s = v;\n      }\n    }\n  }]);\n\n  return RleIntDiffEncoder;\n}(Encoder);\n/**\n * @param {UintOptRleEncoder} encoder\n */\n\nvar flushUintOptRleEncoder = function flushUintOptRleEncoder(encoder) {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);\n\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n};\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\n\n\nexport var UintOptRleEncoder = /*#__PURE__*/function () {\n  function UintOptRleEncoder() {\n    _classCallCheck(this, UintOptRleEncoder);\n\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n\n    this.s = 0;\n    this.count = 0;\n  }\n  /**\n   * @param {number} v\n   */\n\n\n  _createClass(UintOptRleEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.s === v) {\n        this.count++;\n      } else {\n        flushUintOptRleEncoder(this);\n        this.count = 1;\n        this.s = v;\n      }\n    }\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      flushUintOptRleEncoder(this);\n      return _toUint8Array(this.encoder);\n    }\n  }]);\n\n  return UintOptRleEncoder;\n}();\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\n\nexport var IncUintOptRleEncoder = /*#__PURE__*/function () {\n  function IncUintOptRleEncoder() {\n    _classCallCheck(this, IncUintOptRleEncoder);\n\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n\n    this.s = 0;\n    this.count = 0;\n  }\n  /**\n   * @param {number} v\n   */\n\n\n  _createClass(IncUintOptRleEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.s + this.count === v) {\n        this.count++;\n      } else {\n        flushUintOptRleEncoder(this);\n        this.count = 1;\n        this.s = v;\n      }\n    }\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      flushUintOptRleEncoder(this);\n      return _toUint8Array(this.encoder);\n    }\n  }]);\n\n  return IncUintOptRleEncoder;\n}();\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\n\nvar flushIntDiffOptRleEncoder = function flushIntDiffOptRleEncoder(encoder) {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    var encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1); // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n\n    writeVarInt(encoder.encoder, encodedDiff);\n\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n};\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\n\n\nexport var IntDiffOptRleEncoder = /*#__PURE__*/function () {\n  function IntDiffOptRleEncoder() {\n    _classCallCheck(this, IntDiffOptRleEncoder);\n\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n  /**\n   * @param {number} v\n   */\n\n\n  _createClass(IntDiffOptRleEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.diff === v - this.s) {\n        this.s = v;\n        this.count++;\n      } else {\n        flushIntDiffOptRleEncoder(this);\n        this.count = 1;\n        this.diff = v - this.s;\n        this.s = v;\n      }\n    }\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      flushIntDiffOptRleEncoder(this);\n      return _toUint8Array(this.encoder);\n    }\n  }]);\n\n  return IntDiffOptRleEncoder;\n}();\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\n\nexport var StringEncoder = /*#__PURE__*/function () {\n  function StringEncoder() {\n    _classCallCheck(this, StringEncoder);\n\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = [];\n    this.s = '';\n    this.lensE = new UintOptRleEncoder();\n  }\n  /**\n   * @param {string} string\n   */\n\n\n  _createClass(StringEncoder, [{\n    key: \"write\",\n    value: function write(string) {\n      this.s += string;\n\n      if (this.s.length > 19) {\n        this.sarr.push(this.s);\n        this.s = '';\n      }\n\n      this.lensE.write(string.length);\n    }\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      var encoder = new Encoder();\n      this.sarr.push(this.s);\n      this.s = '';\n      writeVarString(encoder, this.sarr.join(''));\n      writeUint8Array(encoder, this.lensE.toUint8Array());\n      return _toUint8Array(encoder);\n    }\n  }]);\n\n  return StringEncoder;\n}();","map":{"version":3,"sources":["/media/neel/DATA/WebD/Smart Doc/client/node_modules/lib0/encoding.js"],"names":["buffer","math","number","binary","Encoder","cpos","cbuf","Uint8Array","bufs","createEncoder","length","encoder","len","i","toUint8Array","uint8arr","curPos","d","set","createUint8ArrayViewFromArrayBuffer","verifyLen","bufferLen","push","max","write","num","pos","b","writeUint8","setUint8","writeUint16","BITS8","setUint16","writeUint32","writeUint32BigEndian","setUint32","writeVarUint","BITS7","BIT8","writeVarInt","isNegative","isNegativeZero","BITS6","BIT7","writeVarString","str","encodedString","unescape","encodeURIComponent","codePointAt","writeBinaryEncoder","append","writeUint8Array","uint8Array","leftCopyLen","min","rightCopyLen","subarray","writeVarUint8Array","byteLength","writeOnDataView","dview","DataView","writeFloat32","setFloat32","writeFloat64","setFloat64","writeBigInt64","setBigInt64","writeBigUint64","setBigUint64","floatTestBed","ArrayBuffer","isFloat32","getFloat32","writeAny","data","isInteger","BITS31","Array","keys","Object","key","RleEncoder","writer","w","s","count","v","IntDiffEncoder","start","RleIntDiffEncoder","flushUintOptRleEncoder","UintOptRleEncoder","IncUintOptRleEncoder","flushIntDiffOptRleEncoder","encodedDiff","diff","IntDiffOptRleEncoder","StringEncoder","sarr","lensE","string","join"],"mappings":"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","sourcesContent":["/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num >>>= 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don't use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num >>>= 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num >>>= 7\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeVarString = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && data <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}