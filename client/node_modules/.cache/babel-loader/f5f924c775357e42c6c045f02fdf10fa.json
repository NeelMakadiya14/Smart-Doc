{"ast":null,"code":"import _createClass from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/media/neel/DATA/WebD/Smart Doc/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\nimport * as buffer from './buffer.js';\nimport * as binary from './binary.js';\nimport * as math from './math.js';\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\n\nexport var Decoder =\n/**\n * @param {Uint8Array} uint8Array Binary data to decode\n */\nfunction Decoder(uint8Array) {\n  _classCallCheck(this, Decoder);\n\n  /**\n   * Decoding target.\n   *\n   * @type {Uint8Array}\n   */\n  this.arr = uint8Array;\n  /**\n   * Current decoding position.\n   *\n   * @type {number}\n   */\n\n  this.pos = 0;\n};\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\n\nexport var createDecoder = function createDecoder(uint8Array) {\n  return new Decoder(uint8Array);\n};\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\n\nexport var hasContent = function hasContent(decoder) {\n  return decoder.pos !== decoder.arr.length;\n};\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\n\nexport var clone = function clone(decoder) {\n  var newPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : decoder.pos;\n\n  var _decoder = createDecoder(decoder.arr);\n\n  _decoder.pos = newPos;\n  return _decoder;\n};\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\n\nexport var readUint8Array = function readUint8Array(decoder, len) {\n  var view = buffer.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view;\n};\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\n\nexport var readVarUint8Array = function readVarUint8Array(decoder) {\n  return readUint8Array(decoder, readVarUint(decoder));\n};\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\n\nexport var readTailAsUint8Array = function readTailAsUint8Array(decoder) {\n  return readUint8Array(decoder, decoder.arr.length - decoder.pos);\n};\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\n\nexport var skip8 = function skip8(decoder) {\n  return decoder.pos++;\n};\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\n\nexport var readUint8 = function readUint8(decoder) {\n  return decoder.arr[decoder.pos++];\n};\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\n\nexport var readUint16 = function readUint16(decoder) {\n  var uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);\n  decoder.pos += 2;\n  return uint;\n};\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\n\nexport var readUint32 = function readUint32(decoder) {\n  var uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;\n  decoder.pos += 4;\n  return uint;\n};\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\n\nexport var readUint32BigEndian = function readUint32BigEndian(decoder) {\n  var uint = decoder.arr[decoder.pos + 3] + (decoder.arr[decoder.pos + 2] << 8) + (decoder.arr[decoder.pos + 1] << 16) + (decoder.arr[decoder.pos] << 24) >>> 0;\n  decoder.pos += 4;\n  return uint;\n};\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\n\nexport var peekUint8 = function peekUint8(decoder) {\n  return decoder.arr[decoder.pos];\n};\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\n\nexport var peekUint16 = function peekUint16(decoder) {\n  return decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);\n};\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\n\nexport var peekUint32 = function peekUint32(decoder) {\n  return decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;\n};\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\n\nexport var readVarUint = function readVarUint(decoder) {\n  var num = 0;\n  var len = 0;\n\n  while (true) {\n    var r = decoder.arr[decoder.pos++];\n    num = num | (r & binary.BITS7) << len;\n    len += 7;\n\n    if (r < binary.BIT8) {\n      return num >>> 0; // return unsigned number!\n    }\n    /* istanbul ignore if */\n\n\n    if (len > 35) {\n      throw new Error('Integer out of range!');\n    }\n  }\n};\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if unmber is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\n\nexport var readVarInt = function readVarInt(decoder) {\n  var r = decoder.arr[decoder.pos++];\n  var num = r & binary.BITS6;\n  var len = 6;\n  var sign = (r & binary.BIT7) > 0 ? -1 : 1;\n\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num;\n  }\n\n  while (true) {\n    r = decoder.arr[decoder.pos++];\n    num = num | (r & binary.BITS7) << len;\n    len += 7;\n\n    if (r < binary.BIT8) {\n      return sign * (num >>> 0);\n    }\n    /* istanbul ignore if */\n\n\n    if (len > 41) {\n      throw new Error('Integer out of range!');\n    }\n  }\n};\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\n\nexport var peekVarUint = function peekVarUint(decoder) {\n  var pos = decoder.pos;\n  var s = readVarUint(decoder);\n  decoder.pos = pos;\n  return s;\n};\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\n\nexport var peekVarInt = function peekVarInt(decoder) {\n  var pos = decoder.pos;\n  var s = readVarInt(decoder);\n  decoder.pos = pos;\n  return s;\n};\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n\nexport var readVarString = function readVarString(decoder) {\n  var remainingLen = readVarUint(decoder);\n\n  if (remainingLen === 0) {\n    return '';\n  } else {\n    var encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n\n    if (--remainingLen < 100) {\n      // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        var nextLen = remainingLen < 10000 ? remainingLen : 10000; // this is dangerous, we create a fresh array view from the existing buffer\n\n        var bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen; // Starting with ES5.1 we can supply a generic array-like object as arguments\n\n        encodedString += String.fromCodePoint.apply(null,\n        /** @type {any} */\n        bytes);\n        remainingLen -= nextLen;\n      }\n    }\n\n    return decodeURIComponent(escape(encodedString));\n  }\n};\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\n\nexport var peekVarString = function peekVarString(decoder) {\n  var pos = decoder.pos;\n  var s = readVarString(decoder);\n  decoder.pos = pos;\n  return s;\n};\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\n\nexport var readFromDataView = function readFromDataView(decoder, len) {\n  var dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);\n  decoder.pos += len;\n  return dv;\n};\n/**\n * @param {Decoder} decoder\n */\n\nexport var readFloat32 = function readFloat32(decoder) {\n  return readFromDataView(decoder, 4).getFloat32(0);\n};\n/**\n * @param {Decoder} decoder\n */\n\nexport var readFloat64 = function readFloat64(decoder) {\n  return readFromDataView(decoder, 8).getFloat64(0);\n};\n/**\n * @param {Decoder} decoder\n */\n\nexport var readBigInt64 = function readBigInt64(decoder) {\n  return (\n    /** @type {any} */\n    readFromDataView(decoder, 8).getBigInt64(0)\n  );\n};\n/**\n * @param {Decoder} decoder\n */\n\nexport var readBigUint64 = function readBigUint64(decoder) {\n  return (\n    /** @type {any} */\n    readFromDataView(decoder, 8).getBigUint64(0)\n  );\n};\n/**\n * @type {Array<function(Decoder):any>}\n */\n\nvar readAnyLookupTable = [function (decoder) {\n  return undefined;\n}, // CASE 127: undefined\nfunction (decoder) {\n  return null;\n}, // CASE 126: null\nreadVarInt, // CASE 125: integer\nreadFloat32, // CASE 124: float32\nreadFloat64, // CASE 123: float64\nreadBigInt64, // CASE 122: bigint\nfunction (decoder) {\n  return false;\n}, // CASE 121: boolean (false)\nfunction (decoder) {\n  return true;\n}, // CASE 120: boolean (true)\nreadVarString, // CASE 119: string\nfunction (decoder) {\n  // CASE 118: object<string,any>\n  var len = readVarUint(decoder);\n  /**\n   * @type {Object<string,any>}\n   */\n\n  var obj = {};\n\n  for (var i = 0; i < len; i++) {\n    var key = readVarString(decoder);\n    obj[key] = readAny(decoder);\n  }\n\n  return obj;\n}, function (decoder) {\n  // CASE 117: array<any>\n  var len = readVarUint(decoder);\n  var arr = [];\n\n  for (var i = 0; i < len; i++) {\n    arr.push(readAny(decoder));\n  }\n\n  return arr;\n}, readVarUint8Array // CASE 116: Uint8Array\n];\n/**\n * @param {Decoder} decoder\n */\n\nexport var readAny = function readAny(decoder) {\n  return readAnyLookupTable[127 - readUint8(decoder)](decoder);\n};\n/**\n * T must not be null.\n *\n * @template T\n */\n\nexport var RleDecoder = /*#__PURE__*/function (_Decoder) {\n  _inherits(RleDecoder, _Decoder);\n\n  var _super = _createSuper(RleDecoder);\n\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  function RleDecoder(uint8Array, reader) {\n    var _this;\n\n    _classCallCheck(this, RleDecoder);\n\n    _this = _super.call(this, uint8Array);\n    /**\n     * The reader\n     */\n\n    _this.reader = reader;\n    /**\n     * Current state\n     * @type {T|null}\n     */\n\n    _this.s = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  _createClass(RleDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        this.s = this.reader(this);\n\n        if (hasContent(this)) {\n          this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n        } else {\n          this.count = -1; // read the current value forever\n        }\n      }\n\n      this.count--;\n      return (\n        /** @type {T} */\n        this.s\n      );\n    }\n  }]);\n\n  return RleDecoder;\n}(Decoder);\nexport var IntDiffDecoder = /*#__PURE__*/function (_Decoder2) {\n  _inherits(IntDiffDecoder, _Decoder2);\n\n  var _super2 = _createSuper(IntDiffDecoder);\n\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  function IntDiffDecoder(uint8Array, start) {\n    var _this2;\n\n    _classCallCheck(this, IntDiffDecoder);\n\n    _this2 = _super2.call(this, uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n\n    _this2.s = start;\n    return _this2;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  _createClass(IntDiffDecoder, [{\n    key: \"read\",\n    value: function read() {\n      this.s += readVarInt(this);\n      return this.s;\n    }\n  }]);\n\n  return IntDiffDecoder;\n}(Decoder);\nexport var RleIntDiffDecoder = /*#__PURE__*/function (_Decoder3) {\n  _inherits(RleIntDiffDecoder, _Decoder3);\n\n  var _super3 = _createSuper(RleIntDiffDecoder);\n\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  function RleIntDiffDecoder(uint8Array, start) {\n    var _this3;\n\n    _classCallCheck(this, RleIntDiffDecoder);\n\n    _this3 = _super3.call(this, uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n\n    _this3.s = start;\n    _this3.count = 0;\n    return _this3;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  _createClass(RleIntDiffDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        this.s += readVarInt(this);\n\n        if (hasContent(this)) {\n          this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n        } else {\n          this.count = -1; // read the current value forever\n        }\n      }\n\n      this.count--;\n      return (\n        /** @type {number} */\n        this.s\n      );\n    }\n  }]);\n\n  return RleIntDiffDecoder;\n}(Decoder);\nexport var UintOptRleDecoder = /*#__PURE__*/function (_Decoder4) {\n  _inherits(UintOptRleDecoder, _Decoder4);\n\n  var _super4 = _createSuper(UintOptRleDecoder);\n\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  function UintOptRleDecoder(uint8Array) {\n    var _this4;\n\n    _classCallCheck(this, UintOptRleDecoder);\n\n    _this4 = _super4.call(this, uint8Array);\n    /**\n     * @type {number}\n     */\n\n    _this4.s = 0;\n    _this4.count = 0;\n    return _this4;\n  }\n\n  _createClass(UintOptRleDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        this.s = readVarInt(this); // if the sign is negative, we read the count too, otherwise count is 1\n\n        var isNegative = math.isNegativeZero(this.s);\n        this.count = 1;\n\n        if (isNegative) {\n          this.s = -this.s;\n          this.count = readVarUint(this) + 2;\n        }\n      }\n\n      this.count--;\n      return (\n        /** @type {number} */\n        this.s\n      );\n    }\n  }]);\n\n  return UintOptRleDecoder;\n}(Decoder);\nexport var IncUintOptRleDecoder = /*#__PURE__*/function (_Decoder5) {\n  _inherits(IncUintOptRleDecoder, _Decoder5);\n\n  var _super5 = _createSuper(IncUintOptRleDecoder);\n\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  function IncUintOptRleDecoder(uint8Array) {\n    var _this5;\n\n    _classCallCheck(this, IncUintOptRleDecoder);\n\n    _this5 = _super5.call(this, uint8Array);\n    /**\n     * @type {number}\n     */\n\n    _this5.s = 0;\n    _this5.count = 0;\n    return _this5;\n  }\n\n  _createClass(IncUintOptRleDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        this.s = readVarInt(this); // if the sign is negative, we read the count too, otherwise count is 1\n\n        var isNegative = math.isNegativeZero(this.s);\n        this.count = 1;\n\n        if (isNegative) {\n          this.s = -this.s;\n          this.count = readVarUint(this) + 2;\n        }\n      }\n\n      this.count--;\n      return (\n        /** @type {number} */\n        this.s++\n      );\n    }\n  }]);\n\n  return IncUintOptRleDecoder;\n}(Decoder);\nexport var IntDiffOptRleDecoder = /*#__PURE__*/function (_Decoder6) {\n  _inherits(IntDiffOptRleDecoder, _Decoder6);\n\n  var _super6 = _createSuper(IntDiffOptRleDecoder);\n\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  function IntDiffOptRleDecoder(uint8Array) {\n    var _this6;\n\n    _classCallCheck(this, IntDiffOptRleDecoder);\n\n    _this6 = _super6.call(this, uint8Array);\n    /**\n     * @type {number}\n     */\n\n    _this6.s = 0;\n    _this6.count = 0;\n    _this6.diff = 0;\n    return _this6;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  _createClass(IntDiffOptRleDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        var diff = readVarInt(this); // if the first bit is set, we read more data\n\n        var hasCount = diff & 1;\n        this.diff = diff >> 1;\n        this.count = 1;\n\n        if (hasCount) {\n          this.count = readVarUint(this) + 2;\n        }\n      }\n\n      this.s += this.diff;\n      this.count--;\n      return this.s;\n    }\n  }]);\n\n  return IntDiffOptRleDecoder;\n}(Decoder);\nexport var StringDecoder = /*#__PURE__*/function () {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  function StringDecoder(uint8Array) {\n    _classCallCheck(this, StringDecoder);\n\n    this.decoder = new UintOptRleDecoder(uint8Array);\n    this.str = readVarString(this.decoder);\n    /**\n     * @type {number}\n     */\n\n    this.spos = 0;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  _createClass(StringDecoder, [{\n    key: \"read\",\n    value: function read() {\n      var end = this.spos + this.decoder.read();\n      var res = this.str.slice(this.spos, end);\n      this.spos = end;\n      return res;\n    }\n  }]);\n\n  return StringDecoder;\n}();","map":{"version":3,"sources":["/media/neel/DATA/WebD/Smart Doc/client/node_modules/lib0/decoding.js"],"names":["buffer","binary","math","Decoder","uint8Array","arr","pos","createDecoder","hasContent","decoder","length","clone","newPos","_decoder","readUint8Array","len","view","createUint8ArrayViewFromArrayBuffer","byteOffset","readVarUint8Array","readVarUint","readTailAsUint8Array","skip8","readUint8","readUint16","uint","readUint32","readUint32BigEndian","peekUint8","peekUint16","peekUint32","num","r","BITS7","BIT8","Error","readVarInt","BITS6","sign","BIT7","peekVarUint","s","peekVarInt","readVarString","remainingLen","encodedString","String","fromCodePoint","nextLen","bytes","subarray","apply","decodeURIComponent","escape","peekVarString","readFromDataView","dv","DataView","readFloat32","getFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readAnyLookupTable","undefined","obj","i","key","readAny","push","RleDecoder","reader","count","IntDiffDecoder","start","RleIntDiffDecoder","UintOptRleDecoder","isNegative","isNegativeZero","IncUintOptRleDecoder","IntDiffOptRleDecoder","diff","hasCount","StringDecoder","str","spos","end","read","res","slice"],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,KAAKA,MAAZ,MAAwB,aAAxB;AACA,OAAO,KAAKC,MAAZ,MAAwB,aAAxB;AACA,OAAO,KAAKC,IAAZ,MAAsB,WAAtB;AAEA;AACA;AACA;;AACA,WAAaC,OAAb;AACE;AACF;AACA;AACE,iBAAaC,UAAb,EAAyB;AAAA;;AACvB;AACJ;AACA;AACA;AACA;AACI,OAAKC,GAAL,GAAWD,UAAX;AACA;AACJ;AACA;AACA;AACA;;AACI,OAAKE,GAAL,GAAW,CAAX;AACD,CAjBH;AAoBA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAH,UAAU;AAAA,SAAI,IAAID,OAAJ,CAAYC,UAAZ,CAAJ;AAAA,CAAhC;AAEP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMI,UAAU,GAAG,SAAbA,UAAa,CAAAC,OAAO;AAAA,SAAIA,OAAO,CAACH,GAAR,KAAgBG,OAAO,CAACJ,GAAR,CAAYK,MAAhC;AAAA,CAA1B;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,KAAK,GAAG,SAARA,KAAQ,CAACF,OAAD,EAAmC;AAAA,MAAzBG,MAAyB,uEAAhBH,OAAO,CAACH,GAAQ;;AACtD,MAAMO,QAAQ,GAAGN,aAAa,CAACE,OAAO,CAACJ,GAAT,CAA9B;;AACAQ,EAAAA,QAAQ,CAACP,GAAT,GAAeM,MAAf;AACA,SAAOC,QAAP;AACD,CAJM;AAMP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACL,OAAD,EAAUM,GAAV,EAAkB;AAC9C,MAAMC,IAAI,GAAGhB,MAAM,CAACiB,mCAAP,CAA2CR,OAAO,CAACJ,GAAR,CAAYL,MAAvD,EAA+DS,OAAO,CAACH,GAAR,GAAcG,OAAO,CAACJ,GAAR,CAAYa,UAAzF,EAAqGH,GAArG,CAAb;AACAN,EAAAA,OAAO,CAACH,GAAR,IAAeS,GAAf;AACA,SAAOC,IAAP;AACD,CAJM;AAMP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMG,iBAAiB,GAAG,SAApBA,iBAAoB,CAAAV,OAAO;AAAA,SAAIK,cAAc,CAACL,OAAD,EAAUW,WAAW,CAACX,OAAD,CAArB,CAAlB;AAAA,CAAjC;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMY,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAAZ,OAAO;AAAA,SAAIK,cAAc,CAACL,OAAD,EAAUA,OAAO,CAACJ,GAAR,CAAYK,MAAZ,GAAqBD,OAAO,CAACH,GAAvC,CAAlB;AAAA,CAApC;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMgB,KAAK,GAAG,SAARA,KAAQ,CAAAb,OAAO;AAAA,SAAIA,OAAO,CAACH,GAAR,EAAJ;AAAA,CAArB;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMiB,SAAS,GAAG,SAAZA,SAAY,CAAAd,OAAO;AAAA,SAAIA,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,EAAZ,CAAJ;AAAA,CAAzB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMkB,UAAU,GAAG,SAAbA,UAAa,CAAAf,OAAO,EAAI;AACnC,MAAMgB,IAAI,GACRhB,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAApB,KACCG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,CADjC,CADF;AAGAG,EAAAA,OAAO,CAACH,GAAR,IAAe,CAAf;AACA,SAAOmB,IAAP;AACD,CANM;AAQP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAAAjB,OAAO,EAAI;AACnC,MAAMgB,IAAI,GACPhB,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAApB,KACAG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,CADhC,KAEAG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,EAFhC,KAGAG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,EAHhC,CAAD,KAG0C,CAJ5C;AAKAG,EAAAA,OAAO,CAACH,GAAR,IAAe,CAAf;AACA,SAAOmB,IAAP;AACD,CARM;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAME,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAAlB,OAAO,EAAI;AAC5C,MAAMgB,IAAI,GACPhB,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KACAG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,CADhC,KAEAG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,EAFhC,KAGAG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAApB,KAA4B,EAH5B,CAAD,KAGsC,CAJxC;AAKAG,EAAAA,OAAO,CAACH,GAAR,IAAe,CAAf;AACA,SAAOmB,IAAP;AACD,CARM;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMG,SAAS,GAAG,SAAZA,SAAY,CAAAnB,OAAO;AAAA,SAAIA,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAApB,CAAJ;AAAA,CAAzB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMuB,UAAU,GAAG,SAAbA,UAAa,CAAApB,OAAO;AAAA,SAC/BA,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAApB,KACCG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,CADjC,CAD+B;AAAA,CAA1B;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMwB,UAAU,GAAG,SAAbA,UAAa,CAAArB,OAAO;AAAA,SAC/BA,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAApB,KACCG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,CADjC,KAECG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,EAFjC,KAGCG,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,GAAc,CAA1B,KAAgC,EAHjC,CADmC,KAK/B,CAL2B;AAAA,CAA1B;AAOP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMc,WAAW,GAAG,SAAdA,WAAc,CAAAX,OAAO,EAAI;AACpC,MAAIsB,GAAG,GAAG,CAAV;AACA,MAAIhB,GAAG,GAAG,CAAV;;AACA,SAAO,IAAP,EAAa;AACX,QAAMiB,CAAC,GAAGvB,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,EAAZ,CAAV;AACAyB,IAAAA,GAAG,GAAGA,GAAG,GAAI,CAACC,CAAC,GAAG/B,MAAM,CAACgC,KAAZ,KAAsBlB,GAAnC;AACAA,IAAAA,GAAG,IAAI,CAAP;;AACA,QAAIiB,CAAC,GAAG/B,MAAM,CAACiC,IAAf,EAAqB;AACnB,aAAOH,GAAG,KAAK,CAAf,CADmB,CACF;AAClB;AACD;;;AACA,QAAIhB,GAAG,GAAG,EAAV,EAAc;AACZ,YAAM,IAAIoB,KAAJ,CAAU,uBAAV,CAAN;AACD;AACF;AACF,CAfM;AAiBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAAA3B,OAAO,EAAI;AACnC,MAAIuB,CAAC,GAAGvB,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,EAAZ,CAAR;AACA,MAAIyB,GAAG,GAAGC,CAAC,GAAG/B,MAAM,CAACoC,KAArB;AACA,MAAItB,GAAG,GAAG,CAAV;AACA,MAAMuB,IAAI,GAAG,CAACN,CAAC,GAAG/B,MAAM,CAACsC,IAAZ,IAAoB,CAApB,GAAwB,CAAC,CAAzB,GAA6B,CAA1C;;AACA,MAAI,CAACP,CAAC,GAAG/B,MAAM,CAACiC,IAAZ,MAAsB,CAA1B,EAA6B;AAC3B;AACA,WAAOI,IAAI,GAAGP,GAAd;AACD;;AACD,SAAO,IAAP,EAAa;AACXC,IAAAA,CAAC,GAAGvB,OAAO,CAACJ,GAAR,CAAYI,OAAO,CAACH,GAAR,EAAZ,CAAJ;AACAyB,IAAAA,GAAG,GAAGA,GAAG,GAAI,CAACC,CAAC,GAAG/B,MAAM,CAACgC,KAAZ,KAAsBlB,GAAnC;AACAA,IAAAA,GAAG,IAAI,CAAP;;AACA,QAAIiB,CAAC,GAAG/B,MAAM,CAACiC,IAAf,EAAqB;AACnB,aAAOI,IAAI,IAAIP,GAAG,KAAK,CAAZ,CAAX;AACD;AACD;;;AACA,QAAIhB,GAAG,GAAG,EAAV,EAAc;AACZ,YAAM,IAAIoB,KAAJ,CAAU,uBAAV,CAAN;AACD;AACF;AACF,CArBM;AAuBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMK,WAAW,GAAG,SAAdA,WAAc,CAAA/B,OAAO,EAAI;AACpC,MAAMH,GAAG,GAAGG,OAAO,CAACH,GAApB;AACA,MAAMmC,CAAC,GAAGrB,WAAW,CAACX,OAAD,CAArB;AACAA,EAAAA,OAAO,CAACH,GAAR,GAAcA,GAAd;AACA,SAAOmC,CAAP;AACD,CALM;AAOP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAAAjC,OAAO,EAAI;AACnC,MAAMH,GAAG,GAAGG,OAAO,CAACH,GAApB;AACA,MAAMmC,CAAC,GAAGL,UAAU,CAAC3B,OAAD,CAApB;AACAA,EAAAA,OAAO,CAACH,GAAR,GAAcA,GAAd;AACA,SAAOmC,CAAP;AACD,CALM;AAOP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAME,aAAa,GAAG,SAAhBA,aAAgB,CAAAlC,OAAO,EAAI;AACtC,MAAImC,YAAY,GAAGxB,WAAW,CAACX,OAAD,CAA9B;;AACA,MAAImC,YAAY,KAAK,CAArB,EAAwB;AACtB,WAAO,EAAP;AACD,GAFD,MAEO;AACL,QAAIC,aAAa,GAAGC,MAAM,CAACC,aAAP,CAAqBxB,SAAS,CAACd,OAAD,CAA9B,CAApB,CADK,CACwD;;AAC7D,QAAI,EAAEmC,YAAF,GAAiB,GAArB,EAA0B;AAAE;AAC1B,aAAOA,YAAY,EAAnB,EAAuB;AACrBC,QAAAA,aAAa,IAAIC,MAAM,CAACC,aAAP,CAAqBxB,SAAS,CAACd,OAAD,CAA9B,CAAjB;AACD;AACF,KAJD,MAIO;AACL,aAAOmC,YAAY,GAAG,CAAtB,EAAyB;AACvB,YAAMI,OAAO,GAAGJ,YAAY,GAAG,KAAf,GAAuBA,YAAvB,GAAsC,KAAtD,CADuB,CAEvB;;AACA,YAAMK,KAAK,GAAGxC,OAAO,CAACJ,GAAR,CAAY6C,QAAZ,CAAqBzC,OAAO,CAACH,GAA7B,EAAkCG,OAAO,CAACH,GAAR,GAAc0C,OAAhD,CAAd;AACAvC,QAAAA,OAAO,CAACH,GAAR,IAAe0C,OAAf,CAJuB,CAKvB;;AACAH,QAAAA,aAAa,IAAIC,MAAM,CAACC,aAAP,CAAqBI,KAArB,CAA2B,IAA3B;AAAiC;AAAoBF,QAAAA,KAArD,CAAjB;AACAL,QAAAA,YAAY,IAAII,OAAhB;AACD;AACF;;AACD,WAAOI,kBAAkB,CAACC,MAAM,CAACR,aAAD,CAAP,CAAzB;AACD;AACF,CAvBM;AAyBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMS,aAAa,GAAG,SAAhBA,aAAgB,CAAA7C,OAAO,EAAI;AACtC,MAAMH,GAAG,GAAGG,OAAO,CAACH,GAApB;AACA,MAAMmC,CAAC,GAAGE,aAAa,CAAClC,OAAD,CAAvB;AACAA,EAAAA,OAAO,CAACH,GAAR,GAAcA,GAAd;AACA,SAAOmC,CAAP;AACD,CALM;AAOP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMc,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAC9C,OAAD,EAAUM,GAAV,EAAkB;AAChD,MAAMyC,EAAE,GAAG,IAAIC,QAAJ,CAAahD,OAAO,CAACJ,GAAR,CAAYL,MAAzB,EAAiCS,OAAO,CAACJ,GAAR,CAAYa,UAAZ,GAAyBT,OAAO,CAACH,GAAlE,EAAuES,GAAvE,CAAX;AACAN,EAAAA,OAAO,CAACH,GAAR,IAAeS,GAAf;AACA,SAAOyC,EAAP;AACD,CAJM;AAMP;AACA;AACA;;AACA,OAAO,IAAME,WAAW,GAAG,SAAdA,WAAc,CAAAjD,OAAO;AAAA,SAAI8C,gBAAgB,CAAC9C,OAAD,EAAU,CAAV,CAAhB,CAA6BkD,UAA7B,CAAwC,CAAxC,CAAJ;AAAA,CAA3B;AAEP;AACA;AACA;;AACA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAAnD,OAAO;AAAA,SAAI8C,gBAAgB,CAAC9C,OAAD,EAAU,CAAV,CAAhB,CAA6BoD,UAA7B,CAAwC,CAAxC,CAAJ;AAAA,CAA3B;AAEP;AACA;AACA;;AACA,OAAO,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAAArD,OAAO;AAAA;AAAI;AAAoB8C,IAAAA,gBAAgB,CAAC9C,OAAD,EAAU,CAAV,CAAjB,CAA+BsD,WAA/B,CAA2C,CAA3C;AAAvB;AAAA,CAA5B;AAEP;AACA;AACA;;AACA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAvD,OAAO;AAAA;AAAI;AAAoB8C,IAAAA,gBAAgB,CAAC9C,OAAD,EAAU,CAAV,CAAjB,CAA+BwD,YAA/B,CAA4C,CAA5C;AAAvB;AAAA,CAA7B;AAEP;AACA;AACA;;AACA,IAAMC,kBAAkB,GAAG,CACzB,UAAAzD,OAAO;AAAA,SAAI0D,SAAJ;AAAA,CADkB,EACH;AACtB,UAAA1D,OAAO;AAAA,SAAI,IAAJ;AAAA,CAFkB,EAER;AACjB2B,UAHyB,EAGb;AACZsB,WAJyB,EAIZ;AACbE,WALyB,EAKZ;AACbE,YANyB,EAMX;AACd,UAAArD,OAAO;AAAA,SAAI,KAAJ;AAAA,CAPkB,EAOP;AAClB,UAAAA,OAAO;AAAA,SAAI,IAAJ;AAAA,CARkB,EAQR;AACjBkC,aATyB,EASV;AACf,UAAAlC,OAAO,EAAI;AAAE;AACX,MAAMM,GAAG,GAAGK,WAAW,CAACX,OAAD,CAAvB;AACA;AACJ;AACA;;AACI,MAAM2D,GAAG,GAAG,EAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtD,GAApB,EAAyBsD,CAAC,EAA1B,EAA8B;AAC5B,QAAMC,GAAG,GAAG3B,aAAa,CAAClC,OAAD,CAAzB;AACA2D,IAAAA,GAAG,CAACE,GAAD,CAAH,GAAWC,OAAO,CAAC9D,OAAD,CAAlB;AACD;;AACD,SAAO2D,GAAP;AACD,CArBwB,EAsBzB,UAAA3D,OAAO,EAAI;AAAE;AACX,MAAMM,GAAG,GAAGK,WAAW,CAACX,OAAD,CAAvB;AACA,MAAMJ,GAAG,GAAG,EAAZ;;AACA,OAAK,IAAIgE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtD,GAApB,EAAyBsD,CAAC,EAA1B,EAA8B;AAC5BhE,IAAAA,GAAG,CAACmE,IAAJ,CAASD,OAAO,CAAC9D,OAAD,CAAhB;AACD;;AACD,SAAOJ,GAAP;AACD,CA7BwB,EA8BzBc,iBA9ByB,CA8BP;AA9BO,CAA3B;AAiCA;AACA;AACA;;AACA,OAAO,IAAMoD,OAAO,GAAG,SAAVA,OAAU,CAAA9D,OAAO;AAAA,SAAIyD,kBAAkB,CAAC,MAAM3C,SAAS,CAACd,OAAD,CAAhB,CAAlB,CAA6CA,OAA7C,CAAJ;AAAA,CAAvB;AAEP;AACA;AACA;AACA;AACA;;AACA,WAAagE,UAAb;AAAA;;AAAA;;AACE;AACF;AACA;AACA;AACE,sBAAarE,UAAb,EAAyBsE,MAAzB,EAAiC;AAAA;;AAAA;;AAC/B,8BAAMtE,UAAN;AACA;AACJ;AACA;;AACI,UAAKsE,MAAL,GAAcA,MAAd;AACA;AACJ;AACA;AACA;;AACI,UAAKjC,CAAL,GAAS,IAAT;AACA,UAAKkC,KAAL,GAAa,CAAb;AAX+B;AAYhC;;AAjBH;AAAA;AAAA,WAmBE,gBAAQ;AACN,UAAI,KAAKA,KAAL,KAAe,CAAnB,EAAsB;AACpB,aAAKlC,CAAL,GAAS,KAAKiC,MAAL,CAAY,IAAZ,CAAT;;AACA,YAAIlE,UAAU,CAAC,IAAD,CAAd,EAAsB;AACpB,eAAKmE,KAAL,GAAavD,WAAW,CAAC,IAAD,CAAX,GAAoB,CAAjC,CADoB,CACe;AACpC,SAFD,MAEO;AACL,eAAKuD,KAAL,GAAa,CAAC,CAAd,CADK,CACW;AACjB;AACF;;AACD,WAAKA,KAAL;AACA;AAAO;AAAkB,aAAKlC;AAA9B;AACD;AA9BH;;AAAA;AAAA,EAAgCtC,OAAhC;AAiCA,WAAayE,cAAb;AAAA;;AAAA;;AACE;AACF;AACA;AACA;AACE,0BAAaxE,UAAb,EAAyByE,KAAzB,EAAgC;AAAA;;AAAA;;AAC9B,gCAAMzE,UAAN;AACA;AACJ;AACA;AACA;;AACI,WAAKqC,CAAL,GAASoC,KAAT;AAN8B;AAO/B;AAED;AACF;AACA;;;AAhBA;AAAA;AAAA,WAiBE,gBAAQ;AACN,WAAKpC,CAAL,IAAUL,UAAU,CAAC,IAAD,CAApB;AACA,aAAO,KAAKK,CAAZ;AACD;AApBH;;AAAA;AAAA,EAAoCtC,OAApC;AAuBA,WAAa2E,iBAAb;AAAA;;AAAA;;AACE;AACF;AACA;AACA;AACE,6BAAa1E,UAAb,EAAyByE,KAAzB,EAAgC;AAAA;;AAAA;;AAC9B,gCAAMzE,UAAN;AACA;AACJ;AACA;AACA;;AACI,WAAKqC,CAAL,GAASoC,KAAT;AACA,WAAKF,KAAL,GAAa,CAAb;AAP8B;AAQ/B;AAED;AACF;AACA;;;AAjBA;AAAA;AAAA,WAkBE,gBAAQ;AACN,UAAI,KAAKA,KAAL,KAAe,CAAnB,EAAsB;AACpB,aAAKlC,CAAL,IAAUL,UAAU,CAAC,IAAD,CAApB;;AACA,YAAI5B,UAAU,CAAC,IAAD,CAAd,EAAsB;AACpB,eAAKmE,KAAL,GAAavD,WAAW,CAAC,IAAD,CAAX,GAAoB,CAAjC,CADoB,CACe;AACpC,SAFD,MAEO;AACL,eAAKuD,KAAL,GAAa,CAAC,CAAd,CADK,CACW;AACjB;AACF;;AACD,WAAKA,KAAL;AACA;AAAO;AAAuB,aAAKlC;AAAnC;AACD;AA7BH;;AAAA;AAAA,EAAuCtC,OAAvC;AAgCA,WAAa4E,iBAAb;AAAA;;AAAA;;AACE;AACF;AACA;AACE,6BAAa3E,UAAb,EAAyB;AAAA;;AAAA;;AACvB,gCAAMA,UAAN;AACA;AACJ;AACA;;AACI,WAAKqC,CAAL,GAAS,CAAT;AACA,WAAKkC,KAAL,GAAa,CAAb;AANuB;AAOxB;;AAXH;AAAA;AAAA,WAaE,gBAAQ;AACN,UAAI,KAAKA,KAAL,KAAe,CAAnB,EAAsB;AACpB,aAAKlC,CAAL,GAASL,UAAU,CAAC,IAAD,CAAnB,CADoB,CAEpB;;AACA,YAAM4C,UAAU,GAAG9E,IAAI,CAAC+E,cAAL,CAAoB,KAAKxC,CAAzB,CAAnB;AACA,aAAKkC,KAAL,GAAa,CAAb;;AACA,YAAIK,UAAJ,EAAgB;AACd,eAAKvC,CAAL,GAAS,CAAC,KAAKA,CAAf;AACA,eAAKkC,KAAL,GAAavD,WAAW,CAAC,IAAD,CAAX,GAAoB,CAAjC;AACD;AACF;;AACD,WAAKuD,KAAL;AACA;AAAO;AAAuB,aAAKlC;AAAnC;AACD;AA1BH;;AAAA;AAAA,EAAuCtC,OAAvC;AA6BA,WAAa+E,oBAAb;AAAA;;AAAA;;AACE;AACF;AACA;AACE,gCAAa9E,UAAb,EAAyB;AAAA;;AAAA;;AACvB,gCAAMA,UAAN;AACA;AACJ;AACA;;AACI,WAAKqC,CAAL,GAAS,CAAT;AACA,WAAKkC,KAAL,GAAa,CAAb;AANuB;AAOxB;;AAXH;AAAA;AAAA,WAaE,gBAAQ;AACN,UAAI,KAAKA,KAAL,KAAe,CAAnB,EAAsB;AACpB,aAAKlC,CAAL,GAASL,UAAU,CAAC,IAAD,CAAnB,CADoB,CAEpB;;AACA,YAAM4C,UAAU,GAAG9E,IAAI,CAAC+E,cAAL,CAAoB,KAAKxC,CAAzB,CAAnB;AACA,aAAKkC,KAAL,GAAa,CAAb;;AACA,YAAIK,UAAJ,EAAgB;AACd,eAAKvC,CAAL,GAAS,CAAC,KAAKA,CAAf;AACA,eAAKkC,KAAL,GAAavD,WAAW,CAAC,IAAD,CAAX,GAAoB,CAAjC;AACD;AACF;;AACD,WAAKuD,KAAL;AACA;AAAO;AAAuB,aAAKlC,CAAL;AAA9B;AACD;AA1BH;;AAAA;AAAA,EAA0CtC,OAA1C;AA6BA,WAAagF,oBAAb;AAAA;;AAAA;;AACE;AACF;AACA;AACE,gCAAa/E,UAAb,EAAyB;AAAA;;AAAA;;AACvB,gCAAMA,UAAN;AACA;AACJ;AACA;;AACI,WAAKqC,CAAL,GAAS,CAAT;AACA,WAAKkC,KAAL,GAAa,CAAb;AACA,WAAKS,IAAL,GAAY,CAAZ;AAPuB;AAQxB;AAED;AACF;AACA;;;AAhBA;AAAA;AAAA,WAiBE,gBAAQ;AACN,UAAI,KAAKT,KAAL,KAAe,CAAnB,EAAsB;AACpB,YAAMS,IAAI,GAAGhD,UAAU,CAAC,IAAD,CAAvB,CADoB,CAEpB;;AACA,YAAMiD,QAAQ,GAAGD,IAAI,GAAG,CAAxB;AACA,aAAKA,IAAL,GAAYA,IAAI,IAAI,CAApB;AACA,aAAKT,KAAL,GAAa,CAAb;;AACA,YAAIU,QAAJ,EAAc;AACZ,eAAKV,KAAL,GAAavD,WAAW,CAAC,IAAD,CAAX,GAAoB,CAAjC;AACD;AACF;;AACD,WAAKqB,CAAL,IAAU,KAAK2C,IAAf;AACA,WAAKT,KAAL;AACA,aAAO,KAAKlC,CAAZ;AACD;AA/BH;;AAAA;AAAA,EAA0CtC,OAA1C;AAkCA,WAAamF,aAAb;AACE;AACF;AACA;AACE,yBAAalF,UAAb,EAAyB;AAAA;;AACvB,SAAKK,OAAL,GAAe,IAAIsE,iBAAJ,CAAsB3E,UAAtB,CAAf;AACA,SAAKmF,GAAL,GAAW5C,aAAa,CAAC,KAAKlC,OAAN,CAAxB;AACA;AACJ;AACA;;AACI,SAAK+E,IAAL,GAAY,CAAZ;AACD;AAED;AACF;AACA;;;AAfA;AAAA;AAAA,WAgBE,gBAAQ;AACN,UAAMC,GAAG,GAAG,KAAKD,IAAL,GAAY,KAAK/E,OAAL,CAAaiF,IAAb,EAAxB;AACA,UAAMC,GAAG,GAAG,KAAKJ,GAAL,CAASK,KAAT,CAAe,KAAKJ,IAApB,EAA0BC,GAA1B,CAAZ;AACA,WAAKD,IAAL,GAAYC,GAAZ;AACA,aAAOE,GAAP;AACD;AArBH;;AAAA;AAAA","sourcesContent":["/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as binary from './binary.js'\nimport * as math from './math.js'\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = buffer.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let len = 0\n  while (true) {\n    const r = decoder.arr[decoder.pos++]\n    num = num | ((r & binary.BITS7) << len)\n    len += 7\n    if (r < binary.BIT8) {\n      return num >>> 0 // return unsigned number!\n    }\n    /* istanbul ignore if */\n    if (len > 35) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if unmber is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let len = 6\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++]\n    num = num | ((r & binary.BITS7) << len)\n    len += 7\n    if (r < binary.BIT8) {\n      return sign * (num >>> 0)\n    }\n    /* istanbul ignore if */\n    if (len > 41) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\nexport const readVarString = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = diff >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n"]},"metadata":{},"sourceType":"module"}