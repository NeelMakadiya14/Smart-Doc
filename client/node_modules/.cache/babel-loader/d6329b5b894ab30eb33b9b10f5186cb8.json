{"ast":null,"code":"/**\n * Utility module to work with strings.\n *\n * @module string\n */\nexport var fromCharCode = String.fromCharCode;\nexport var fromCodePoint = String.fromCodePoint;\n/**\n * @param {string} s\n * @return {string}\n */\n\nvar toLowerCase = function toLowerCase(s) {\n  return s.toLowerCase();\n};\n\nvar trimLeftRegex = /^\\s*/g;\n/**\n * @param {string} s\n * @return {string}\n */\n\nexport var trimLeft = function trimLeft(s) {\n  return s.replace(trimLeftRegex, '');\n};\nvar fromCamelCaseRegex = /([A-Z])/g;\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\n\nexport var fromCamelCase = function fromCamelCase(s, separator) {\n  return trimLeft(s.replace(fromCamelCaseRegex, function (match) {\n    return \"\".concat(separator).concat(toLowerCase(match));\n  }));\n};\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\n\nexport var utf8ByteLength = function utf8ByteLength(str) {\n  return unescape(encodeURIComponent(str)).length;\n};\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n\nexport var _encodeUtf8Polyfill = function _encodeUtf8Polyfill(str) {\n  var encodedString = unescape(encodeURIComponent(str));\n  var len = encodedString.length;\n  var buf = new Uint8Array(len);\n\n  for (var i = 0; i < len; i++) {\n    buf[i] =\n    /** @type {number} */\n    encodedString.codePointAt(i);\n  }\n\n  return buf;\n};\n/* istanbul ignore next */\n\nexport var utf8TextEncoder =\n/** @type {TextEncoder} */\ntypeof TextEncoder !== 'undefined' ? new TextEncoder() : null;\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n\nexport var _encodeUtf8Native = function _encodeUtf8Native(str) {\n  return utf8TextEncoder.encode(str);\n};\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n\n/* istanbul ignore next */\n\nexport var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n\nexport var _decodeUtf8Polyfill = function _decodeUtf8Polyfill(buf) {\n  var remainingLen = buf.length;\n  var encodedString = '';\n  var bufPos = 0;\n\n  while (remainingLen > 0) {\n    var nextLen = remainingLen < 10000 ? remainingLen : 10000;\n    var bytes = buf.subarray(bufPos, bufPos + nextLen);\n    bufPos += nextLen; // Starting with ES5.1 we can supply a generic array-like object as arguments\n\n    encodedString += String.fromCodePoint.apply(null,\n    /** @type {any} */\n    bytes);\n    remainingLen -= nextLen;\n  }\n\n  return decodeURIComponent(escape(encodedString));\n};\n/* istanbul ignore next */\n\nexport var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', {\n  fatal: true,\n  ignoreBOM: true\n});\n/* istanbul ignore next */\n\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n\n  /* istanbul ignore next */\n  utf8TextDecoder = null;\n}\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n\n\nexport var _decodeUtf8Native = function _decodeUtf8Native(buf) {\n  return (\n    /** @type {TextDecoder} */\n    utf8TextDecoder.decode(buf)\n  );\n};\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n\n/* istanbul ignore next */\n\nexport var decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill;","map":{"version":3,"sources":["/media/neel/DATA/WebD/Smart Doc/client/node_modules/lib0/string.js"],"names":["fromCharCode","String","fromCodePoint","toLowerCase","s","trimLeftRegex","trimLeft","replace","fromCamelCaseRegex","fromCamelCase","separator","match","utf8ByteLength","str","unescape","encodeURIComponent","length","_encodeUtf8Polyfill","encodedString","len","buf","Uint8Array","i","codePointAt","utf8TextEncoder","TextEncoder","_encodeUtf8Native","encode","encodeUtf8","_decodeUtf8Polyfill","remainingLen","bufPos","nextLen","bytes","subarray","apply","decodeURIComponent","escape","utf8TextDecoder","TextDecoder","fatal","ignoreBOM","decode","_decodeUtf8Native","decodeUtf8"],"mappings":"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","sourcesContent":["/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nexport const fromCharCode = String.fromCharCode\nexport const fromCodePoint = String.fromCodePoint\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nexport const trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nexport const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nexport const utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* istanbul ignore next */\nexport const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* istanbul ignore next */\nexport const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* istanbul ignore next */\nexport let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* istanbul ignore next */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* istanbul ignore next */\n  utf8TextDecoder = null\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* istanbul ignore next */\nexport const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n"]},"metadata":{},"sourceType":"module"}